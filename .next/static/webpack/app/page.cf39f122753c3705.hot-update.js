/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./node_modules/hex-to-css-filter/dist/umd/hex-to-css-filter.js":
/*!**********************************************************************!*\
  !*** ./node_modules/hex-to-css-filter/dist/umd/hex-to-css-filter.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval(__webpack_require__.ts("(function (global, factory) {\n     true ? factory(exports) :\n    0;\n})(this, (function (exports) { 'use strict';\n\n    /******************************************************************************\r\n    Copyright (c) Microsoft Corporation.\r\n\r\n    Permission to use, copy, modify, and/or distribute this software for any\r\n    purpose with or without fee is hereby granted.\r\n\r\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\n    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\n    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\n    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\n    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\n    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\n    PERFORMANCE OF THIS SOFTWARE.\r\n    ***************************************************************************** */\r\n\r\n    function __read(o, n) {\r\n        var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n        if (!m) return o;\r\n        var i = m.call(o), r, ar = [], e;\r\n        try {\r\n            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n        }\r\n        catch (error) { e = { error: error }; }\r\n        finally {\r\n            try {\r\n                if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n            }\r\n            finally { if (e) throw e.error; }\r\n        }\r\n        return ar;\r\n    }\r\n\r\n    typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n        var e = new Error(message);\r\n        return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n    };\n\n    var Color = /** @class */ (function () {\n        function Color(r, g, b) {\n            this.r = 0;\n            this.g = 0;\n            this.b = 0;\n            this.set(r, g, b);\n        }\n        Color.prototype.set = function (r, g, b) {\n            this.r = this.clamp(r);\n            this.g = this.clamp(g);\n            this.b = this.clamp(b);\n        };\n        /**\n         * Applying cals to get CSS filter for hue-rotate\n         *\n         * @param {number} [angle=0]\n         * @memberof Color\n         */\n        Color.prototype.hueRotate = function (angle) {\n            if (angle === void 0) { angle = 0; }\n            angle = (angle / 180) * Math.PI;\n            var sin = Math.sin(angle);\n            var cos = Math.cos(angle);\n            this.multiply([\n                0.213 + cos * 0.787 - sin * 0.213,\n                0.715 - cos * 0.715 - sin * 0.715,\n                0.072 - cos * 0.072 + sin * 0.928,\n                0.213 - cos * 0.213 + sin * 0.143,\n                0.715 + cos * 0.285 + sin * 0.14,\n                0.072 - cos * 0.072 - sin * 0.283,\n                0.213 - cos * 0.213 - sin * 0.787,\n                0.715 - cos * 0.715 + sin * 0.715,\n                0.072 + cos * 0.928 + sin * 0.072,\n            ]);\n        };\n        /**\n         * Applying cals to get CSS filter for grayscale\n         *\n         * @param {number} [value=1]\n         * @memberof Color\n         */\n        Color.prototype.grayscale = function (value) {\n            if (value === void 0) { value = 1; }\n            this.multiply([\n                0.2126 + 0.7874 * (1 - value),\n                0.7152 - 0.7152 * (1 - value),\n                0.0722 - 0.0722 * (1 - value),\n                0.2126 - 0.2126 * (1 - value),\n                0.7152 + 0.2848 * (1 - value),\n                0.0722 - 0.0722 * (1 - value),\n                0.2126 - 0.2126 * (1 - value),\n                0.7152 - 0.7152 * (1 - value),\n                0.0722 + 0.9278 * (1 - value),\n            ]);\n        };\n        /**\n         * Applying cals to get CSS filter for sepia\n         *\n         * @param {number} [value=1]\n         * @memberof Color\n         */\n        Color.prototype.sepia = function (value) {\n            if (value === void 0) { value = 1; }\n            this.multiply([\n                0.393 + 0.607 * (1 - value),\n                0.769 - 0.769 * (1 - value),\n                0.189 - 0.189 * (1 - value),\n                0.349 - 0.349 * (1 - value),\n                0.686 + 0.314 * (1 - value),\n                0.168 - 0.168 * (1 - value),\n                0.272 - 0.272 * (1 - value),\n                0.534 - 0.534 * (1 - value),\n                0.131 + 0.869 * (1 - value),\n            ]);\n        };\n        /**\n         * Applying cals to get CSS filter for saturate\n         *\n         * @param {number} [value=1]\n         * @memberof Color\n         */\n        Color.prototype.saturate = function (value) {\n            if (value === void 0) { value = 1; }\n            this.multiply([\n                0.213 + 0.787 * value,\n                0.715 - 0.715 * value,\n                0.072 - 0.072 * value,\n                0.213 - 0.213 * value,\n                0.715 + 0.285 * value,\n                0.072 - 0.072 * value,\n                0.213 - 0.213 * value,\n                0.715 - 0.715 * value,\n                0.072 + 0.928 * value,\n            ]);\n        };\n        Color.prototype.multiply = function (matrix) {\n            // These values are needed. It's correct because the returned values will change\n            var newR = this.clamp(this.r * matrix[0] + this.g * matrix[1] + this.b * matrix[2]);\n            var newG = this.clamp(this.r * matrix[3] + this.g * matrix[4] + this.b * matrix[5]);\n            var newB = this.clamp(this.r * matrix[6] + this.g * matrix[7] + this.b * matrix[8]);\n            this.r = newR;\n            this.g = newG;\n            this.b = newB;\n        };\n        /**\n         * Applying cals to get CSS filter for brightness\n         *\n         * @param {number} [value=1]\n         * @memberof Color\n         */\n        Color.prototype.brightness = function (value) {\n            if (value === void 0) { value = 1; }\n            this.linear(value);\n        };\n        /**\n         * Applying cals to get CSS filter for contrast\n         *\n         * @param {number} [value=1]\n         * @memberof Color\n         */\n        Color.prototype.contrast = function (value) {\n            if (value === void 0) { value = 1; }\n            this.linear(value, -(0.5 * value) + 0.5);\n        };\n        Color.prototype.linear = function (slope, intercept) {\n            if (slope === void 0) { slope = 1; }\n            if (intercept === void 0) { intercept = 0; }\n            this.r = this.clamp(this.r * slope + intercept * 255);\n            this.g = this.clamp(this.g * slope + intercept * 255);\n            this.b = this.clamp(this.b * slope + intercept * 255);\n        };\n        /**\n         * Applying cals to get CSS filter for invert\n         *\n         * @param {number} [value=1]\n         * @memberof Color\n         */\n        Color.prototype.invert = function (value) {\n            if (value === void 0) { value = 1; }\n            this.r = this.clamp((value + (this.r / 255) * (1 - 2 * value)) * 255);\n            this.g = this.clamp((value + (this.g / 255) * (1 - 2 * value)) * 255);\n            this.b = this.clamp((value + (this.b / 255) * (1 - 2 * value)) * 255);\n        };\n        /**\n         * transform RGB into HSL values\n         *\n         * @returns {HSLData}\n         * @memberof Color\n         */\n        Color.prototype.hsl = function () {\n            var red = this.r / 255;\n            var green = this.g / 255;\n            var blue = this.b / 255;\n            // find greatest and smallest channel values\n            var max = Math.max(red, green, blue);\n            var min = Math.min(red, green, blue);\n            var hue = 0;\n            var saturation = 0;\n            var lightness = (max + min) / 2;\n            // If min and max have the same values, it means\n            // the given color is achromatic\n            if (max === min) {\n                return {\n                    h: 0,\n                    s: 0,\n                    l: lightness * 100,\n                };\n            }\n            // Adding delta value of greatest and smallest channel values\n            var delta = max - min;\n            saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);\n            if (max === red) {\n                hue = (green - blue) / delta + (green < blue ? 6 : 0);\n            }\n            else if (max === green) {\n                hue = (blue - red) / delta + 2;\n            }\n            else if (max === blue) {\n                hue = (red - green) / delta + 4;\n            }\n            hue /= 6;\n            return {\n                h: hue * 100,\n                s: saturation * 100,\n                l: lightness * 100,\n            };\n        };\n        /**\n         * Normalize the value to follow the min and max for RGB colors\n         * min: 0\n         * max: 255\n         *\n         * @private\n         * @param {number} value\n         * @returns {number}\n         * @memberof Color\n         */\n        Color.prototype.clamp = function (value) {\n            // Minimum RGB Value = 0;\n            // Maximum RGB Value = 255;\n            return Math.min(Math.max(value, 0), 255);\n        };\n        return Color;\n    }());\n\n    var Solver = /** @class */ (function () {\n        function Solver(target, options) {\n            this.target = target;\n            this.targetHSL = target.hsl();\n            this.options = Object.assign({}, \n            // Adding default values for options\n            {\n                acceptanceLossPercentage: 5,\n                maxChecks: 15,\n            }, options);\n            // All the calcs done by the library to generate\n            // a CSS Filter are based on the color `#000`\n            // in this case, `rgb(0, 0, 0)`\n            // Please make sure the background of the element\n            // is `#000` for better performance\n            // and color similarity.\n            this.reusedColor = new Color(0, 0, 0);\n        }\n        /**\n         * Returns the solved values for the\n         *\n         * @returns {(SPSAPayload & { filter: string; })}\n         * @memberof Solver\n         */\n        Solver.prototype.solve = function () {\n            var result = this.solveNarrow(this.solveWide());\n            return {\n                values: result.values,\n                called: result.called,\n                loss: result.loss,\n                filter: this.css(result.values),\n            };\n        };\n        /**\n         * Solve wide values based on the wide values for RGB and HSL values\n         *\n         * @private\n         * @returns {SPSAPayload}\n         * @memberof Solver\n         */\n        Solver.prototype.solveWide = function () {\n            var A = 5;\n            var c = 15;\n            // Wide values for RGB and HSL values\n            // the values in the order: [`r`, `g`, `b`, `h`, `s`, `l`]\n            var a = [60, 180, 18000, 600, 1.2, 1.2];\n            var best = { loss: Infinity };\n            var counter = 0;\n            while (best.loss > this.options.acceptanceLossPercentage) {\n                var initialFilterValues = [50, 20, 3750, 50, 100, 100];\n                var result = this.spsa({\n                    A: A,\n                    a: a,\n                    c: c,\n                    values: initialFilterValues,\n                    // for wide values we should use the double of tries in\n                    // comparison of `solveNarrow()` method\n                    maxTriesInLoop: 1000,\n                });\n                if (result.loss < best.loss) {\n                    best = result;\n                }\n                counter += 1;\n                if (counter >= this.options.maxChecks) {\n                    break;\n                }\n            }\n            return Object.assign({}, best, { called: counter });\n        };\n        /**\n         * Solve narrow values based on the wide values for the filter\n         *\n         * @private\n         * @param {SPSAPayload} wide\n         * @returns {SPSAPayload}\n         * @memberof Solver\n         */\n        Solver.prototype.solveNarrow = function (wide) {\n            var A = wide.loss;\n            var c = 2;\n            var A1 = A + 1;\n            // Narrow values for RGB and HSL values\n            // the values in the order: [`r`, `g`, `b`, `h`, `s`, `l`]\n            var a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];\n            return this.spsa({\n                A: A,\n                a: a,\n                c: c,\n                values: wide.values,\n                maxTriesInLoop: 500,\n                called: wide.called,\n            });\n        };\n        /**\n         * Returns final value based on the current filter order\n         * to get the order, please check the returned value\n         * in `css()` method\n         *\n         * @private\n         * @param {number} value\n         * @param {number} idx\n         * @returns {number}\n         * @memberof Solver\n         */\n        Solver.prototype.fixValueByFilterIDX = function (value, idx) {\n            var max = 100;\n            // Fixing max, minimum and value by filter\n            if (idx === 2 /* saturate */) {\n                max = 7500;\n            }\n            else if (idx === 4 /* brightness */ || idx === 5 /* contrast */) {\n                max = 200;\n            }\n            if (idx === 3 /* hue-rotate */) {\n                if (value > max) {\n                    value %= max;\n                }\n                else if (value < 0) {\n                    value = max + (value % max);\n                }\n            }\n            // Checking if value is below the minimum or above\n            // the maximum allowed by filter\n            else if (value < 0) {\n                value = 0;\n            }\n            else if (value > max) {\n                value = max;\n            }\n            return value;\n        };\n        Solver.prototype.spsa = function (_a) {\n            var A = _a.A, a = _a.a, c = _a.c, values = _a.values, _b = _a.maxTriesInLoop, maxTriesInLoop = _b === void 0 ? 500 : _b, _c = _a.called, called = _c === void 0 ? 0 : _c;\n            var alpha = 1;\n            var gamma = 0.16666666666666666;\n            var best = null;\n            var bestLoss = Infinity;\n            var deltas = new Array(6);\n            var highArgs = new Array(6);\n            var lowArgs = new Array(6);\n            // Size of all CSS filters to be applied to get the correct color\n            var filtersToBeAppliedSize = 6;\n            for (var key = 0; key < maxTriesInLoop; key++) {\n                var ck = c / Math.pow(key + 1, gamma);\n                for (var i = 0; i < filtersToBeAppliedSize; i++) {\n                    deltas[i] = Math.random() > 0.5 ? 1 : -1;\n                    highArgs[i] = values[i] + ck * deltas[i];\n                    lowArgs[i] = values[i] - ck * deltas[i];\n                }\n                var lossDiff = this.loss(highArgs) - this.loss(lowArgs);\n                for (var i = 0; i < filtersToBeAppliedSize; i++) {\n                    var g = (lossDiff / (2 * ck)) * deltas[i];\n                    var ak = a[i] / Math.pow(A + key + 1, alpha);\n                    values[i] = this.fixValueByFilterIDX(values[i] - ak * g, i);\n                }\n                var loss = this.loss(values);\n                if (loss < bestLoss) {\n                    best = values.slice(0);\n                    bestLoss = loss;\n                }\n            }\n            return { values: best, loss: bestLoss, called: called };\n        };\n        /**\n         * Checks how much is the loss for the filter in RGB and HSL colors\n         *\n         * @private\n         * @param {SPSAPayload['values']} filters\n         * @returns {number}\n         * @memberof Solver\n         */\n        Solver.prototype.loss = function (filters) {\n            // Argument as an Array of percentages.\n            var color = this.reusedColor;\n            // Resetting the color to black in case\n            // it was called more than once\n            color.set(0, 0, 0);\n            color.invert(filters[0] / 100);\n            color.sepia(filters[1] / 100);\n            color.saturate(filters[2] / 100);\n            color.hueRotate(filters[3] * 3.6);\n            color.brightness(filters[4] / 100);\n            color.contrast(filters[5] / 100);\n            var colorHSL = color.hsl();\n            return (Math.abs(color.r - this.target.r) +\n                Math.abs(color.g - this.target.g) +\n                Math.abs(color.b - this.target.b) +\n                Math.abs(colorHSL.h - this.targetHSL.h) +\n                Math.abs(colorHSL.s - this.targetHSL.s) +\n                Math.abs(colorHSL.l - this.targetHSL.l));\n        };\n        /**\n         * Returns the CSS filter list for the received HEX color\n         *\n         * @private\n         * @param {number[]} filters\n         * @returns {string}\n         * @memberof Solver\n         */\n        Solver.prototype.css = function (filters) {\n            var formatCssFilterValueByMultiplier = function (idx, multiplier) {\n                if (multiplier === void 0) { multiplier = 1; }\n                return Math.round(filters[idx] * multiplier);\n            };\n            return [\n                \"invert(\".concat(formatCssFilterValueByMultiplier(0), \"%)\"),\n                \"sepia(\".concat(formatCssFilterValueByMultiplier(1), \"%)\"),\n                \"saturate(\".concat(formatCssFilterValueByMultiplier(2), \"%)\"),\n                \"hue-rotate(\".concat(formatCssFilterValueByMultiplier(3, 3.6), \"deg)\"),\n                \"brightness(\".concat(formatCssFilterValueByMultiplier(4), \"%)\"),\n                \"contrast(\".concat(formatCssFilterValueByMultiplier(5), \"%)\"),\n            ].join(' ');\n        };\n        return Solver;\n    }());\n\n    /**\n     * Transform a CSS Color from Hexadecimal to RGB color\n     *\n     * @param {string} hex hexadecimal color\n     * @returns {([number, number, number] | [])} array with the RGB colors or empty array\n     */\n    var hexToRgb = function (hex) {\n        if (hex.length === 4) {\n            return [parseInt(\"0x\".concat(hex[1]).concat(hex[1])), parseInt(\"0x\".concat(hex[2]).concat(hex[2])), parseInt(\"0x\".concat(hex[3]).concat(hex[3]))];\n        }\n        if (hex.length === 7) {\n            return [parseInt(\"0x\".concat(hex[1]).concat(hex[2])), parseInt(\"0x\".concat(hex[3]).concat(hex[4])), parseInt(\"0x\".concat(hex[5]).concat(hex[6]))];\n        }\n        return [];\n    };\n    var isNumeric = function (n) { return !isNaN(parseFloat(n)) && isFinite(n); };\n    // Memory cache for the computed results to avoid multiple\n    // calculations for the same color\n    var results = {};\n    /**\n     * A function that transforms a HEX color into CSS filters\n     *\n     * @param colorValue string hexadecimal color\n     * @param opts HexToCssConfiguration function configuration\n     *\n     */\n    var hexToCSSFilter = function (colorValue, opts) {\n        var _a;\n        if (opts === void 0) { opts = {}; }\n        var red;\n        var green;\n        var blue;\n        if (results[colorValue] && !opts.forceFilterRecalculation) {\n            return Object.assign({}, results[colorValue], { cache: true });\n        }\n        var color;\n        try {\n            _a = __read(hexToRgb(colorValue), 3), red = _a[0], green = _a[1], blue = _a[2];\n            if (!isNumeric(red) || !isNumeric(green) || !isNumeric(blue)) {\n                throw new Error(\"hextToRgb returned an invalid value for '\".concat(colorValue, \"'\"));\n            }\n            color = new Color(Number(red), Number(green), Number(blue));\n        }\n        catch (error) {\n            throw new Error(\"Color value should be in HEX format. \".concat(error));\n        }\n        var solver = new Solver(color, Object.assign({}, \n        // `HexToCssConfiguration` Defaults\n        {\n            acceptanceLossPercentage: 5,\n            maxChecks: 30,\n            forceFilterRecalculation: false,\n        }, opts));\n        return (results[colorValue] = Object.assign({}, solver.solve(), {\n            hex: colorValue,\n            rgb: [red, green, blue],\n            cache: false,\n        }));\n    };\n    /**\n     * A function that clears cached results\n     *\n     * @param  {string} key? HEX string value passed previously `#24639C`. If not passed, it clears all cached results\n     * @returns void\n     */\n    var clearCache = function (key) {\n        if (!key) {\n            results = {};\n        }\n        else if (results[key]) {\n            delete results[key];\n        }\n    };\n\n    exports.clearCache = clearCache;\n    exports.hexToCSSFilter = hexToCSSFilter;\n\n    Object.defineProperty(exports, '__esModule', { value: true });\n\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9oZXgtdG8tY3NzLWZpbHRlci9kaXN0L3VtZC9oZXgtdG8tY3NzLWZpbHRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLElBQUksS0FBNEQ7QUFDaEUsSUFBSSxDQUMrRztBQUNuSCxDQUFDLDhCQUE4Qjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsTUFBTTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCLGlCQUFpQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsVUFBVSxpQkFBaUI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixhQUFhO0FBQ2hDLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzQkFBc0I7QUFDcEQ7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUJBQXVCO0FBQzFDLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFVBQVU7QUFDN0IscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixpQ0FBaUM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlCQUF5QixhQUFhO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1EQUFtRCxhQUFhOztBQUVoRSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9oZXgtdG8tY3NzLWZpbHRlci9kaXN0L3VtZC9oZXgtdG8tY3NzLWZpbHRlci5qcz83NjkxIl0sInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gICAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gZmFjdG9yeShleHBvcnRzKSA6XG4gICAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKFsnZXhwb3J0cyddLCBmYWN0b3J5KSA6XG4gICAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZmFjdG9yeShnbG9iYWwuSGV4VG9DU1NGaWx0ZXIgPSB7fSkpO1xufSkodGhpcywgKGZ1bmN0aW9uIChleHBvcnRzKSB7ICd1c2Ugc3RyaWN0JztcblxuICAgIC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuICAgIENvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuICAgIFBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG4gICAgcHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuICAgIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG4gICAgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG4gICAgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbiAgICBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG4gICAgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG4gICAgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG4gICAgZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgICAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICAgICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgICAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFyO1xyXG4gICAgfVxyXG5cclxuICAgIHR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbiAgICB9O1xuXG4gICAgdmFyIENvbG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBDb2xvcihyLCBnLCBiKSB7XG4gICAgICAgICAgICB0aGlzLnIgPSAwO1xuICAgICAgICAgICAgdGhpcy5nID0gMDtcbiAgICAgICAgICAgIHRoaXMuYiA9IDA7XG4gICAgICAgICAgICB0aGlzLnNldChyLCBnLCBiKTtcbiAgICAgICAgfVxuICAgICAgICBDb2xvci5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHIsIGcsIGIpIHtcbiAgICAgICAgICAgIHRoaXMuciA9IHRoaXMuY2xhbXAocik7XG4gICAgICAgICAgICB0aGlzLmcgPSB0aGlzLmNsYW1wKGcpO1xuICAgICAgICAgICAgdGhpcy5iID0gdGhpcy5jbGFtcChiKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGx5aW5nIGNhbHMgdG8gZ2V0IENTUyBmaWx0ZXIgZm9yIGh1ZS1yb3RhdGVcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IFthbmdsZT0wXVxuICAgICAgICAgKiBAbWVtYmVyb2YgQ29sb3JcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS5odWVSb3RhdGUgPSBmdW5jdGlvbiAoYW5nbGUpIHtcbiAgICAgICAgICAgIGlmIChhbmdsZSA9PT0gdm9pZCAwKSB7IGFuZ2xlID0gMDsgfVxuICAgICAgICAgICAgYW5nbGUgPSAoYW5nbGUgLyAxODApICogTWF0aC5QSTtcbiAgICAgICAgICAgIHZhciBzaW4gPSBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgICAgICB2YXIgY29zID0gTWF0aC5jb3MoYW5nbGUpO1xuICAgICAgICAgICAgdGhpcy5tdWx0aXBseShbXG4gICAgICAgICAgICAgICAgMC4yMTMgKyBjb3MgKiAwLjc4NyAtIHNpbiAqIDAuMjEzLFxuICAgICAgICAgICAgICAgIDAuNzE1IC0gY29zICogMC43MTUgLSBzaW4gKiAwLjcxNSxcbiAgICAgICAgICAgICAgICAwLjA3MiAtIGNvcyAqIDAuMDcyICsgc2luICogMC45MjgsXG4gICAgICAgICAgICAgICAgMC4yMTMgLSBjb3MgKiAwLjIxMyArIHNpbiAqIDAuMTQzLFxuICAgICAgICAgICAgICAgIDAuNzE1ICsgY29zICogMC4yODUgKyBzaW4gKiAwLjE0LFxuICAgICAgICAgICAgICAgIDAuMDcyIC0gY29zICogMC4wNzIgLSBzaW4gKiAwLjI4MyxcbiAgICAgICAgICAgICAgICAwLjIxMyAtIGNvcyAqIDAuMjEzIC0gc2luICogMC43ODcsXG4gICAgICAgICAgICAgICAgMC43MTUgLSBjb3MgKiAwLjcxNSArIHNpbiAqIDAuNzE1LFxuICAgICAgICAgICAgICAgIDAuMDcyICsgY29zICogMC45MjggKyBzaW4gKiAwLjA3MixcbiAgICAgICAgICAgIF0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbHlpbmcgY2FscyB0byBnZXQgQ1NTIGZpbHRlciBmb3IgZ3JheXNjYWxlXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmFsdWU9MV1cbiAgICAgICAgICogQG1lbWJlcm9mIENvbG9yXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5wcm90b3R5cGUuZ3JheXNjYWxlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IDE7IH1cbiAgICAgICAgICAgIHRoaXMubXVsdGlwbHkoW1xuICAgICAgICAgICAgICAgIDAuMjEyNiArIDAuNzg3NCAqICgxIC0gdmFsdWUpLFxuICAgICAgICAgICAgICAgIDAuNzE1MiAtIDAuNzE1MiAqICgxIC0gdmFsdWUpLFxuICAgICAgICAgICAgICAgIDAuMDcyMiAtIDAuMDcyMiAqICgxIC0gdmFsdWUpLFxuICAgICAgICAgICAgICAgIDAuMjEyNiAtIDAuMjEyNiAqICgxIC0gdmFsdWUpLFxuICAgICAgICAgICAgICAgIDAuNzE1MiArIDAuMjg0OCAqICgxIC0gdmFsdWUpLFxuICAgICAgICAgICAgICAgIDAuMDcyMiAtIDAuMDcyMiAqICgxIC0gdmFsdWUpLFxuICAgICAgICAgICAgICAgIDAuMjEyNiAtIDAuMjEyNiAqICgxIC0gdmFsdWUpLFxuICAgICAgICAgICAgICAgIDAuNzE1MiAtIDAuNzE1MiAqICgxIC0gdmFsdWUpLFxuICAgICAgICAgICAgICAgIDAuMDcyMiArIDAuOTI3OCAqICgxIC0gdmFsdWUpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBseWluZyBjYWxzIHRvIGdldCBDU1MgZmlsdGVyIGZvciBzZXBpYVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZhbHVlPTFdXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb2xvclxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IucHJvdG90eXBlLnNlcGlhID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IDE7IH1cbiAgICAgICAgICAgIHRoaXMubXVsdGlwbHkoW1xuICAgICAgICAgICAgICAgIDAuMzkzICsgMC42MDcgKiAoMSAtIHZhbHVlKSxcbiAgICAgICAgICAgICAgICAwLjc2OSAtIDAuNzY5ICogKDEgLSB2YWx1ZSksXG4gICAgICAgICAgICAgICAgMC4xODkgLSAwLjE4OSAqICgxIC0gdmFsdWUpLFxuICAgICAgICAgICAgICAgIDAuMzQ5IC0gMC4zNDkgKiAoMSAtIHZhbHVlKSxcbiAgICAgICAgICAgICAgICAwLjY4NiArIDAuMzE0ICogKDEgLSB2YWx1ZSksXG4gICAgICAgICAgICAgICAgMC4xNjggLSAwLjE2OCAqICgxIC0gdmFsdWUpLFxuICAgICAgICAgICAgICAgIDAuMjcyIC0gMC4yNzIgKiAoMSAtIHZhbHVlKSxcbiAgICAgICAgICAgICAgICAwLjUzNCAtIDAuNTM0ICogKDEgLSB2YWx1ZSksXG4gICAgICAgICAgICAgICAgMC4xMzEgKyAwLjg2OSAqICgxIC0gdmFsdWUpLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBseWluZyBjYWxzIHRvIGdldCBDU1MgZmlsdGVyIGZvciBzYXR1cmF0ZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZhbHVlPTFdXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb2xvclxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IucHJvdG90eXBlLnNhdHVyYXRlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IDE7IH1cbiAgICAgICAgICAgIHRoaXMubXVsdGlwbHkoW1xuICAgICAgICAgICAgICAgIDAuMjEzICsgMC43ODcgKiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAwLjcxNSAtIDAuNzE1ICogdmFsdWUsXG4gICAgICAgICAgICAgICAgMC4wNzIgLSAwLjA3MiAqIHZhbHVlLFxuICAgICAgICAgICAgICAgIDAuMjEzIC0gMC4yMTMgKiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAwLjcxNSArIDAuMjg1ICogdmFsdWUsXG4gICAgICAgICAgICAgICAgMC4wNzIgLSAwLjA3MiAqIHZhbHVlLFxuICAgICAgICAgICAgICAgIDAuMjEzIC0gMC4yMTMgKiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAwLjcxNSAtIDAuNzE1ICogdmFsdWUsXG4gICAgICAgICAgICAgICAgMC4wNzIgKyAwLjkyOCAqIHZhbHVlLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgIH07XG4gICAgICAgIENvbG9yLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIChtYXRyaXgpIHtcbiAgICAgICAgICAgIC8vIFRoZXNlIHZhbHVlcyBhcmUgbmVlZGVkLiBJdCdzIGNvcnJlY3QgYmVjYXVzZSB0aGUgcmV0dXJuZWQgdmFsdWVzIHdpbGwgY2hhbmdlXG4gICAgICAgICAgICB2YXIgbmV3UiA9IHRoaXMuY2xhbXAodGhpcy5yICogbWF0cml4WzBdICsgdGhpcy5nICogbWF0cml4WzFdICsgdGhpcy5iICogbWF0cml4WzJdKTtcbiAgICAgICAgICAgIHZhciBuZXdHID0gdGhpcy5jbGFtcCh0aGlzLnIgKiBtYXRyaXhbM10gKyB0aGlzLmcgKiBtYXRyaXhbNF0gKyB0aGlzLmIgKiBtYXRyaXhbNV0pO1xuICAgICAgICAgICAgdmFyIG5ld0IgPSB0aGlzLmNsYW1wKHRoaXMuciAqIG1hdHJpeFs2XSArIHRoaXMuZyAqIG1hdHJpeFs3XSArIHRoaXMuYiAqIG1hdHJpeFs4XSk7XG4gICAgICAgICAgICB0aGlzLnIgPSBuZXdSO1xuICAgICAgICAgICAgdGhpcy5nID0gbmV3RztcbiAgICAgICAgICAgIHRoaXMuYiA9IG5ld0I7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBseWluZyBjYWxzIHRvIGdldCBDU1MgZmlsdGVyIGZvciBicmlnaHRuZXNzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmFsdWU9MV1cbiAgICAgICAgICogQG1lbWJlcm9mIENvbG9yXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5wcm90b3R5cGUuYnJpZ2h0bmVzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSAxOyB9XG4gICAgICAgICAgICB0aGlzLmxpbmVhcih2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBseWluZyBjYWxzIHRvIGdldCBDU1MgZmlsdGVyIGZvciBjb250cmFzdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ZhbHVlPTFdXG4gICAgICAgICAqIEBtZW1iZXJvZiBDb2xvclxuICAgICAgICAgKi9cbiAgICAgICAgQ29sb3IucHJvdG90eXBlLmNvbnRyYXN0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IDE7IH1cbiAgICAgICAgICAgIHRoaXMubGluZWFyKHZhbHVlLCAtKDAuNSAqIHZhbHVlKSArIDAuNSk7XG4gICAgICAgIH07XG4gICAgICAgIENvbG9yLnByb3RvdHlwZS5saW5lYXIgPSBmdW5jdGlvbiAoc2xvcGUsIGludGVyY2VwdCkge1xuICAgICAgICAgICAgaWYgKHNsb3BlID09PSB2b2lkIDApIHsgc2xvcGUgPSAxOyB9XG4gICAgICAgICAgICBpZiAoaW50ZXJjZXB0ID09PSB2b2lkIDApIHsgaW50ZXJjZXB0ID0gMDsgfVxuICAgICAgICAgICAgdGhpcy5yID0gdGhpcy5jbGFtcCh0aGlzLnIgKiBzbG9wZSArIGludGVyY2VwdCAqIDI1NSk7XG4gICAgICAgICAgICB0aGlzLmcgPSB0aGlzLmNsYW1wKHRoaXMuZyAqIHNsb3BlICsgaW50ZXJjZXB0ICogMjU1KTtcbiAgICAgICAgICAgIHRoaXMuYiA9IHRoaXMuY2xhbXAodGhpcy5iICogc2xvcGUgKyBpbnRlcmNlcHQgKiAyNTUpO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQXBwbHlpbmcgY2FscyB0byBnZXQgQ1NTIGZpbHRlciBmb3IgaW52ZXJ0XG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmFsdWU9MV1cbiAgICAgICAgICogQG1lbWJlcm9mIENvbG9yXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IDE7IH1cbiAgICAgICAgICAgIHRoaXMuciA9IHRoaXMuY2xhbXAoKHZhbHVlICsgKHRoaXMuciAvIDI1NSkgKiAoMSAtIDIgKiB2YWx1ZSkpICogMjU1KTtcbiAgICAgICAgICAgIHRoaXMuZyA9IHRoaXMuY2xhbXAoKHZhbHVlICsgKHRoaXMuZyAvIDI1NSkgKiAoMSAtIDIgKiB2YWx1ZSkpICogMjU1KTtcbiAgICAgICAgICAgIHRoaXMuYiA9IHRoaXMuY2xhbXAoKHZhbHVlICsgKHRoaXMuYiAvIDI1NSkgKiAoMSAtIDIgKiB2YWx1ZSkpICogMjU1KTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHRyYW5zZm9ybSBSR0IgaW50byBIU0wgdmFsdWVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEByZXR1cm5zIHtIU0xEYXRhfVxuICAgICAgICAgKiBAbWVtYmVyb2YgQ29sb3JcbiAgICAgICAgICovXG4gICAgICAgIENvbG9yLnByb3RvdHlwZS5oc2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVkID0gdGhpcy5yIC8gMjU1O1xuICAgICAgICAgICAgdmFyIGdyZWVuID0gdGhpcy5nIC8gMjU1O1xuICAgICAgICAgICAgdmFyIGJsdWUgPSB0aGlzLmIgLyAyNTU7XG4gICAgICAgICAgICAvLyBmaW5kIGdyZWF0ZXN0IGFuZCBzbWFsbGVzdCBjaGFubmVsIHZhbHVlc1xuICAgICAgICAgICAgdmFyIG1heCA9IE1hdGgubWF4KHJlZCwgZ3JlZW4sIGJsdWUpO1xuICAgICAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHJlZCwgZ3JlZW4sIGJsdWUpO1xuICAgICAgICAgICAgdmFyIGh1ZSA9IDA7XG4gICAgICAgICAgICB2YXIgc2F0dXJhdGlvbiA9IDA7XG4gICAgICAgICAgICB2YXIgbGlnaHRuZXNzID0gKG1heCArIG1pbikgLyAyO1xuICAgICAgICAgICAgLy8gSWYgbWluIGFuZCBtYXggaGF2ZSB0aGUgc2FtZSB2YWx1ZXMsIGl0IG1lYW5zXG4gICAgICAgICAgICAvLyB0aGUgZ2l2ZW4gY29sb3IgaXMgYWNocm9tYXRpY1xuICAgICAgICAgICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaDogMCxcbiAgICAgICAgICAgICAgICAgICAgczogMCxcbiAgICAgICAgICAgICAgICAgICAgbDogbGlnaHRuZXNzICogMTAwLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGRpbmcgZGVsdGEgdmFsdWUgb2YgZ3JlYXRlc3QgYW5kIHNtYWxsZXN0IGNoYW5uZWwgdmFsdWVzXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBtYXggLSBtaW47XG4gICAgICAgICAgICBzYXR1cmF0aW9uID0gbGlnaHRuZXNzID4gMC41ID8gZGVsdGEgLyAoMiAtIG1heCAtIG1pbikgOiBkZWx0YSAvIChtYXggKyBtaW4pO1xuICAgICAgICAgICAgaWYgKG1heCA9PT0gcmVkKSB7XG4gICAgICAgICAgICAgICAgaHVlID0gKGdyZWVuIC0gYmx1ZSkgLyBkZWx0YSArIChncmVlbiA8IGJsdWUgPyA2IDogMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXggPT09IGdyZWVuKSB7XG4gICAgICAgICAgICAgICAgaHVlID0gKGJsdWUgLSByZWQpIC8gZGVsdGEgKyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWF4ID09PSBibHVlKSB7XG4gICAgICAgICAgICAgICAgaHVlID0gKHJlZCAtIGdyZWVuKSAvIGRlbHRhICsgNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGh1ZSAvPSA2O1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBoOiBodWUgKiAxMDAsXG4gICAgICAgICAgICAgICAgczogc2F0dXJhdGlvbiAqIDEwMCxcbiAgICAgICAgICAgICAgICBsOiBsaWdodG5lc3MgKiAxMDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogTm9ybWFsaXplIHRoZSB2YWx1ZSB0byBmb2xsb3cgdGhlIG1pbiBhbmQgbWF4IGZvciBSR0IgY29sb3JzXG4gICAgICAgICAqIG1pbjogMFxuICAgICAgICAgKiBtYXg6IDI1NVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICogQG1lbWJlcm9mIENvbG9yXG4gICAgICAgICAqL1xuICAgICAgICBDb2xvci5wcm90b3R5cGUuY2xhbXAgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIC8vIE1pbmltdW0gUkdCIFZhbHVlID0gMDtcbiAgICAgICAgICAgIC8vIE1heGltdW0gUkdCIFZhbHVlID0gMjU1O1xuICAgICAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCAwKSwgMjU1KTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIENvbG9yO1xuICAgIH0oKSk7XG5cbiAgICB2YXIgU29sdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBTb2x2ZXIodGFyZ2V0LCBvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0SFNMID0gdGFyZ2V0LmhzbCgpO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgXG4gICAgICAgICAgICAvLyBBZGRpbmcgZGVmYXVsdCB2YWx1ZXMgZm9yIG9wdGlvbnNcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhY2NlcHRhbmNlTG9zc1BlcmNlbnRhZ2U6IDUsXG4gICAgICAgICAgICAgICAgbWF4Q2hlY2tzOiAxNSxcbiAgICAgICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gQWxsIHRoZSBjYWxjcyBkb25lIGJ5IHRoZSBsaWJyYXJ5IHRvIGdlbmVyYXRlXG4gICAgICAgICAgICAvLyBhIENTUyBGaWx0ZXIgYXJlIGJhc2VkIG9uIHRoZSBjb2xvciBgIzAwMGBcbiAgICAgICAgICAgIC8vIGluIHRoaXMgY2FzZSwgYHJnYigwLCAwLCAwKWBcbiAgICAgICAgICAgIC8vIFBsZWFzZSBtYWtlIHN1cmUgdGhlIGJhY2tncm91bmQgb2YgdGhlIGVsZW1lbnRcbiAgICAgICAgICAgIC8vIGlzIGAjMDAwYCBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlXG4gICAgICAgICAgICAvLyBhbmQgY29sb3Igc2ltaWxhcml0eS5cbiAgICAgICAgICAgIHRoaXMucmV1c2VkQ29sb3IgPSBuZXcgQ29sb3IoMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIHNvbHZlZCB2YWx1ZXMgZm9yIHRoZVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7KFNQU0FQYXlsb2FkICYgeyBmaWx0ZXI6IHN0cmluZzsgfSl9XG4gICAgICAgICAqIEBtZW1iZXJvZiBTb2x2ZXJcbiAgICAgICAgICovXG4gICAgICAgIFNvbHZlci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5zb2x2ZU5hcnJvdyh0aGlzLnNvbHZlV2lkZSgpKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiByZXN1bHQudmFsdWVzLFxuICAgICAgICAgICAgICAgIGNhbGxlZDogcmVzdWx0LmNhbGxlZCxcbiAgICAgICAgICAgICAgICBsb3NzOiByZXN1bHQubG9zcyxcbiAgICAgICAgICAgICAgICBmaWx0ZXI6IHRoaXMuY3NzKHJlc3VsdC52YWx1ZXMpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNvbHZlIHdpZGUgdmFsdWVzIGJhc2VkIG9uIHRoZSB3aWRlIHZhbHVlcyBmb3IgUkdCIGFuZCBIU0wgdmFsdWVzXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEByZXR1cm5zIHtTUFNBUGF5bG9hZH1cbiAgICAgICAgICogQG1lbWJlcm9mIFNvbHZlclxuICAgICAgICAgKi9cbiAgICAgICAgU29sdmVyLnByb3RvdHlwZS5zb2x2ZVdpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgQSA9IDU7XG4gICAgICAgICAgICB2YXIgYyA9IDE1O1xuICAgICAgICAgICAgLy8gV2lkZSB2YWx1ZXMgZm9yIFJHQiBhbmQgSFNMIHZhbHVlc1xuICAgICAgICAgICAgLy8gdGhlIHZhbHVlcyBpbiB0aGUgb3JkZXI6IFtgcmAsIGBnYCwgYGJgLCBgaGAsIGBzYCwgYGxgXVxuICAgICAgICAgICAgdmFyIGEgPSBbNjAsIDE4MCwgMTgwMDAsIDYwMCwgMS4yLCAxLjJdO1xuICAgICAgICAgICAgdmFyIGJlc3QgPSB7IGxvc3M6IEluZmluaXR5IH07XG4gICAgICAgICAgICB2YXIgY291bnRlciA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoYmVzdC5sb3NzID4gdGhpcy5vcHRpb25zLmFjY2VwdGFuY2VMb3NzUGVyY2VudGFnZSkge1xuICAgICAgICAgICAgICAgIHZhciBpbml0aWFsRmlsdGVyVmFsdWVzID0gWzUwLCAyMCwgMzc1MCwgNTAsIDEwMCwgMTAwXTtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5zcHNhKHtcbiAgICAgICAgICAgICAgICAgICAgQTogQSxcbiAgICAgICAgICAgICAgICAgICAgYTogYSxcbiAgICAgICAgICAgICAgICAgICAgYzogYyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiBpbml0aWFsRmlsdGVyVmFsdWVzLFxuICAgICAgICAgICAgICAgICAgICAvLyBmb3Igd2lkZSB2YWx1ZXMgd2Ugc2hvdWxkIHVzZSB0aGUgZG91YmxlIG9mIHRyaWVzIGluXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbXBhcmlzb24gb2YgYHNvbHZlTmFycm93KClgIG1ldGhvZFxuICAgICAgICAgICAgICAgICAgICBtYXhUcmllc0luTG9vcDogMTAwMCxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0Lmxvc3MgPCBiZXN0Lmxvc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYmVzdCA9IHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY291bnRlciArPSAxO1xuICAgICAgICAgICAgICAgIGlmIChjb3VudGVyID49IHRoaXMub3B0aW9ucy5tYXhDaGVja3MpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGJlc3QsIHsgY2FsbGVkOiBjb3VudGVyIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogU29sdmUgbmFycm93IHZhbHVlcyBiYXNlZCBvbiB0aGUgd2lkZSB2YWx1ZXMgZm9yIHRoZSBmaWx0ZXJcbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtTUFNBUGF5bG9hZH0gd2lkZVxuICAgICAgICAgKiBAcmV0dXJucyB7U1BTQVBheWxvYWR9XG4gICAgICAgICAqIEBtZW1iZXJvZiBTb2x2ZXJcbiAgICAgICAgICovXG4gICAgICAgIFNvbHZlci5wcm90b3R5cGUuc29sdmVOYXJyb3cgPSBmdW5jdGlvbiAod2lkZSkge1xuICAgICAgICAgICAgdmFyIEEgPSB3aWRlLmxvc3M7XG4gICAgICAgICAgICB2YXIgYyA9IDI7XG4gICAgICAgICAgICB2YXIgQTEgPSBBICsgMTtcbiAgICAgICAgICAgIC8vIE5hcnJvdyB2YWx1ZXMgZm9yIFJHQiBhbmQgSFNMIHZhbHVlc1xuICAgICAgICAgICAgLy8gdGhlIHZhbHVlcyBpbiB0aGUgb3JkZXI6IFtgcmAsIGBnYCwgYGJgLCBgaGAsIGBzYCwgYGxgXVxuICAgICAgICAgICAgdmFyIGEgPSBbMC4yNSAqIEExLCAwLjI1ICogQTEsIEExLCAwLjI1ICogQTEsIDAuMiAqIEExLCAwLjIgKiBBMV07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zcHNhKHtcbiAgICAgICAgICAgICAgICBBOiBBLFxuICAgICAgICAgICAgICAgIGE6IGEsXG4gICAgICAgICAgICAgICAgYzogYyxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHdpZGUudmFsdWVzLFxuICAgICAgICAgICAgICAgIG1heFRyaWVzSW5Mb29wOiA1MDAsXG4gICAgICAgICAgICAgICAgY2FsbGVkOiB3aWRlLmNhbGxlZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBmaW5hbCB2YWx1ZSBiYXNlZCBvbiB0aGUgY3VycmVudCBmaWx0ZXIgb3JkZXJcbiAgICAgICAgICogdG8gZ2V0IHRoZSBvcmRlciwgcGxlYXNlIGNoZWNrIHRoZSByZXR1cm5lZCB2YWx1ZVxuICAgICAgICAgKiBpbiBgY3NzKClgIG1ldGhvZFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGlkeFxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAgICAgKiBAbWVtYmVyb2YgU29sdmVyXG4gICAgICAgICAqL1xuICAgICAgICBTb2x2ZXIucHJvdG90eXBlLmZpeFZhbHVlQnlGaWx0ZXJJRFggPSBmdW5jdGlvbiAodmFsdWUsIGlkeCkge1xuICAgICAgICAgICAgdmFyIG1heCA9IDEwMDtcbiAgICAgICAgICAgIC8vIEZpeGluZyBtYXgsIG1pbmltdW0gYW5kIHZhbHVlIGJ5IGZpbHRlclxuICAgICAgICAgICAgaWYgKGlkeCA9PT0gMiAvKiBzYXR1cmF0ZSAqLykge1xuICAgICAgICAgICAgICAgIG1heCA9IDc1MDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpZHggPT09IDQgLyogYnJpZ2h0bmVzcyAqLyB8fCBpZHggPT09IDUgLyogY29udHJhc3QgKi8pIHtcbiAgICAgICAgICAgICAgICBtYXggPSAyMDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaWR4ID09PSAzIC8qIGh1ZS1yb3RhdGUgKi8pIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgJT0gbWF4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBtYXggKyAodmFsdWUgJSBtYXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNraW5nIGlmIHZhbHVlIGlzIGJlbG93IHRoZSBtaW5pbXVtIG9yIGFib3ZlXG4gICAgICAgICAgICAvLyB0aGUgbWF4aW11bSBhbGxvd2VkIGJ5IGZpbHRlclxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1heDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgU29sdmVyLnByb3RvdHlwZS5zcHNhID0gZnVuY3Rpb24gKF9hKSB7XG4gICAgICAgICAgICB2YXIgQSA9IF9hLkEsIGEgPSBfYS5hLCBjID0gX2EuYywgdmFsdWVzID0gX2EudmFsdWVzLCBfYiA9IF9hLm1heFRyaWVzSW5Mb29wLCBtYXhUcmllc0luTG9vcCA9IF9iID09PSB2b2lkIDAgPyA1MDAgOiBfYiwgX2MgPSBfYS5jYWxsZWQsIGNhbGxlZCA9IF9jID09PSB2b2lkIDAgPyAwIDogX2M7XG4gICAgICAgICAgICB2YXIgYWxwaGEgPSAxO1xuICAgICAgICAgICAgdmFyIGdhbW1hID0gMC4xNjY2NjY2NjY2NjY2NjY2NjtcbiAgICAgICAgICAgIHZhciBiZXN0ID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBiZXN0TG9zcyA9IEluZmluaXR5O1xuICAgICAgICAgICAgdmFyIGRlbHRhcyA9IG5ldyBBcnJheSg2KTtcbiAgICAgICAgICAgIHZhciBoaWdoQXJncyA9IG5ldyBBcnJheSg2KTtcbiAgICAgICAgICAgIHZhciBsb3dBcmdzID0gbmV3IEFycmF5KDYpO1xuICAgICAgICAgICAgLy8gU2l6ZSBvZiBhbGwgQ1NTIGZpbHRlcnMgdG8gYmUgYXBwbGllZCB0byBnZXQgdGhlIGNvcnJlY3QgY29sb3JcbiAgICAgICAgICAgIHZhciBmaWx0ZXJzVG9CZUFwcGxpZWRTaXplID0gNjtcbiAgICAgICAgICAgIGZvciAodmFyIGtleSA9IDA7IGtleSA8IG1heFRyaWVzSW5Mb29wOyBrZXkrKykge1xuICAgICAgICAgICAgICAgIHZhciBjayA9IGMgLyBNYXRoLnBvdyhrZXkgKyAxLCBnYW1tYSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWx0ZXJzVG9CZUFwcGxpZWRTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsdGFzW2ldID0gTWF0aC5yYW5kb20oKSA+IDAuNSA/IDEgOiAtMTtcbiAgICAgICAgICAgICAgICAgICAgaGlnaEFyZ3NbaV0gPSB2YWx1ZXNbaV0gKyBjayAqIGRlbHRhc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgbG93QXJnc1tpXSA9IHZhbHVlc1tpXSAtIGNrICogZGVsdGFzW2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbG9zc0RpZmYgPSB0aGlzLmxvc3MoaGlnaEFyZ3MpIC0gdGhpcy5sb3NzKGxvd0FyZ3MpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsdGVyc1RvQmVBcHBsaWVkU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBnID0gKGxvc3NEaWZmIC8gKDIgKiBjaykpICogZGVsdGFzW2ldO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYWsgPSBhW2ldIC8gTWF0aC5wb3coQSArIGtleSArIDEsIGFscGhhKTtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2ldID0gdGhpcy5maXhWYWx1ZUJ5RmlsdGVySURYKHZhbHVlc1tpXSAtIGFrICogZywgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsb3NzID0gdGhpcy5sb3NzKHZhbHVlcyk7XG4gICAgICAgICAgICAgICAgaWYgKGxvc3MgPCBiZXN0TG9zcykge1xuICAgICAgICAgICAgICAgICAgICBiZXN0ID0gdmFsdWVzLnNsaWNlKDApO1xuICAgICAgICAgICAgICAgICAgICBiZXN0TG9zcyA9IGxvc3M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWVzOiBiZXN0LCBsb3NzOiBiZXN0TG9zcywgY2FsbGVkOiBjYWxsZWQgfTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrcyBob3cgbXVjaCBpcyB0aGUgbG9zcyBmb3IgdGhlIGZpbHRlciBpbiBSR0IgYW5kIEhTTCBjb2xvcnNcbiAgICAgICAgICpcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtTUFNBUGF5bG9hZFsndmFsdWVzJ119IGZpbHRlcnNcbiAgICAgICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgICAgICogQG1lbWJlcm9mIFNvbHZlclxuICAgICAgICAgKi9cbiAgICAgICAgU29sdmVyLnByb3RvdHlwZS5sb3NzID0gZnVuY3Rpb24gKGZpbHRlcnMpIHtcbiAgICAgICAgICAgIC8vIEFyZ3VtZW50IGFzIGFuIEFycmF5IG9mIHBlcmNlbnRhZ2VzLlxuICAgICAgICAgICAgdmFyIGNvbG9yID0gdGhpcy5yZXVzZWRDb2xvcjtcbiAgICAgICAgICAgIC8vIFJlc2V0dGluZyB0aGUgY29sb3IgdG8gYmxhY2sgaW4gY2FzZVxuICAgICAgICAgICAgLy8gaXQgd2FzIGNhbGxlZCBtb3JlIHRoYW4gb25jZVxuICAgICAgICAgICAgY29sb3Iuc2V0KDAsIDAsIDApO1xuICAgICAgICAgICAgY29sb3IuaW52ZXJ0KGZpbHRlcnNbMF0gLyAxMDApO1xuICAgICAgICAgICAgY29sb3Iuc2VwaWEoZmlsdGVyc1sxXSAvIDEwMCk7XG4gICAgICAgICAgICBjb2xvci5zYXR1cmF0ZShmaWx0ZXJzWzJdIC8gMTAwKTtcbiAgICAgICAgICAgIGNvbG9yLmh1ZVJvdGF0ZShmaWx0ZXJzWzNdICogMy42KTtcbiAgICAgICAgICAgIGNvbG9yLmJyaWdodG5lc3MoZmlsdGVyc1s0XSAvIDEwMCk7XG4gICAgICAgICAgICBjb2xvci5jb250cmFzdChmaWx0ZXJzWzVdIC8gMTAwKTtcbiAgICAgICAgICAgIHZhciBjb2xvckhTTCA9IGNvbG9yLmhzbCgpO1xuICAgICAgICAgICAgcmV0dXJuIChNYXRoLmFicyhjb2xvci5yIC0gdGhpcy50YXJnZXQucikgK1xuICAgICAgICAgICAgICAgIE1hdGguYWJzKGNvbG9yLmcgLSB0aGlzLnRhcmdldC5nKSArXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoY29sb3IuYiAtIHRoaXMudGFyZ2V0LmIpICtcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhjb2xvckhTTC5oIC0gdGhpcy50YXJnZXRIU0wuaCkgK1xuICAgICAgICAgICAgICAgIE1hdGguYWJzKGNvbG9ySFNMLnMgLSB0aGlzLnRhcmdldEhTTC5zKSArXG4gICAgICAgICAgICAgICAgTWF0aC5hYnMoY29sb3JIU0wubCAtIHRoaXMudGFyZ2V0SFNMLmwpKTtcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHVybnMgdGhlIENTUyBmaWx0ZXIgbGlzdCBmb3IgdGhlIHJlY2VpdmVkIEhFWCBjb2xvclxuICAgICAgICAgKlxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcltdfSBmaWx0ZXJzXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICAgICAqIEBtZW1iZXJvZiBTb2x2ZXJcbiAgICAgICAgICovXG4gICAgICAgIFNvbHZlci5wcm90b3R5cGUuY3NzID0gZnVuY3Rpb24gKGZpbHRlcnMpIHtcbiAgICAgICAgICAgIHZhciBmb3JtYXRDc3NGaWx0ZXJWYWx1ZUJ5TXVsdGlwbGllciA9IGZ1bmN0aW9uIChpZHgsIG11bHRpcGxpZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAobXVsdGlwbGllciA9PT0gdm9pZCAwKSB7IG11bHRpcGxpZXIgPSAxOyB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoZmlsdGVyc1tpZHhdICogbXVsdGlwbGllcik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBcImludmVydChcIi5jb25jYXQoZm9ybWF0Q3NzRmlsdGVyVmFsdWVCeU11bHRpcGxpZXIoMCksIFwiJSlcIiksXG4gICAgICAgICAgICAgICAgXCJzZXBpYShcIi5jb25jYXQoZm9ybWF0Q3NzRmlsdGVyVmFsdWVCeU11bHRpcGxpZXIoMSksIFwiJSlcIiksXG4gICAgICAgICAgICAgICAgXCJzYXR1cmF0ZShcIi5jb25jYXQoZm9ybWF0Q3NzRmlsdGVyVmFsdWVCeU11bHRpcGxpZXIoMiksIFwiJSlcIiksXG4gICAgICAgICAgICAgICAgXCJodWUtcm90YXRlKFwiLmNvbmNhdChmb3JtYXRDc3NGaWx0ZXJWYWx1ZUJ5TXVsdGlwbGllcigzLCAzLjYpLCBcImRlZylcIiksXG4gICAgICAgICAgICAgICAgXCJicmlnaHRuZXNzKFwiLmNvbmNhdChmb3JtYXRDc3NGaWx0ZXJWYWx1ZUJ5TXVsdGlwbGllcig0KSwgXCIlKVwiKSxcbiAgICAgICAgICAgICAgICBcImNvbnRyYXN0KFwiLmNvbmNhdChmb3JtYXRDc3NGaWx0ZXJWYWx1ZUJ5TXVsdGlwbGllcig1KSwgXCIlKVwiKSxcbiAgICAgICAgICAgIF0uam9pbignICcpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gU29sdmVyO1xuICAgIH0oKSk7XG5cbiAgICAvKipcbiAgICAgKiBUcmFuc2Zvcm0gYSBDU1MgQ29sb3IgZnJvbSBIZXhhZGVjaW1hbCB0byBSR0IgY29sb3JcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZXggaGV4YWRlY2ltYWwgY29sb3JcbiAgICAgKiBAcmV0dXJucyB7KFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSB8IFtdKX0gYXJyYXkgd2l0aCB0aGUgUkdCIGNvbG9ycyBvciBlbXB0eSBhcnJheVxuICAgICAqL1xuICAgIHZhciBoZXhUb1JnYiA9IGZ1bmN0aW9uIChoZXgpIHtcbiAgICAgICAgaWYgKGhleC5sZW5ndGggPT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiBbcGFyc2VJbnQoXCIweFwiLmNvbmNhdChoZXhbMV0pLmNvbmNhdChoZXhbMV0pKSwgcGFyc2VJbnQoXCIweFwiLmNvbmNhdChoZXhbMl0pLmNvbmNhdChoZXhbMl0pKSwgcGFyc2VJbnQoXCIweFwiLmNvbmNhdChoZXhbM10pLmNvbmNhdChoZXhbM10pKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhleC5sZW5ndGggPT09IDcpIHtcbiAgICAgICAgICAgIHJldHVybiBbcGFyc2VJbnQoXCIweFwiLmNvbmNhdChoZXhbMV0pLmNvbmNhdChoZXhbMl0pKSwgcGFyc2VJbnQoXCIweFwiLmNvbmNhdChoZXhbM10pLmNvbmNhdChoZXhbNF0pKSwgcGFyc2VJbnQoXCIweFwiLmNvbmNhdChoZXhbNV0pLmNvbmNhdChoZXhbNl0pKV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH07XG4gICAgdmFyIGlzTnVtZXJpYyA9IGZ1bmN0aW9uIChuKSB7IHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7IH07XG4gICAgLy8gTWVtb3J5IGNhY2hlIGZvciB0aGUgY29tcHV0ZWQgcmVzdWx0cyB0byBhdm9pZCBtdWx0aXBsZVxuICAgIC8vIGNhbGN1bGF0aW9ucyBmb3IgdGhlIHNhbWUgY29sb3JcbiAgICB2YXIgcmVzdWx0cyA9IHt9O1xuICAgIC8qKlxuICAgICAqIEEgZnVuY3Rpb24gdGhhdCB0cmFuc2Zvcm1zIGEgSEVYIGNvbG9yIGludG8gQ1NTIGZpbHRlcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb2xvclZhbHVlIHN0cmluZyBoZXhhZGVjaW1hbCBjb2xvclxuICAgICAqIEBwYXJhbSBvcHRzIEhleFRvQ3NzQ29uZmlndXJhdGlvbiBmdW5jdGlvbiBjb25maWd1cmF0aW9uXG4gICAgICpcbiAgICAgKi9cbiAgICB2YXIgaGV4VG9DU1NGaWx0ZXIgPSBmdW5jdGlvbiAoY29sb3JWYWx1ZSwgb3B0cykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChvcHRzID09PSB2b2lkIDApIHsgb3B0cyA9IHt9OyB9XG4gICAgICAgIHZhciByZWQ7XG4gICAgICAgIHZhciBncmVlbjtcbiAgICAgICAgdmFyIGJsdWU7XG4gICAgICAgIGlmIChyZXN1bHRzW2NvbG9yVmFsdWVdICYmICFvcHRzLmZvcmNlRmlsdGVyUmVjYWxjdWxhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlc3VsdHNbY29sb3JWYWx1ZV0sIHsgY2FjaGU6IHRydWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbG9yO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgX2EgPSBfX3JlYWQoaGV4VG9SZ2IoY29sb3JWYWx1ZSksIDMpLCByZWQgPSBfYVswXSwgZ3JlZW4gPSBfYVsxXSwgYmx1ZSA9IF9hWzJdO1xuICAgICAgICAgICAgaWYgKCFpc051bWVyaWMocmVkKSB8fCAhaXNOdW1lcmljKGdyZWVuKSB8fCAhaXNOdW1lcmljKGJsdWUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaGV4dFRvUmdiIHJldHVybmVkIGFuIGludmFsaWQgdmFsdWUgZm9yICdcIi5jb25jYXQoY29sb3JWYWx1ZSwgXCInXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbG9yID0gbmV3IENvbG9yKE51bWJlcihyZWQpLCBOdW1iZXIoZ3JlZW4pLCBOdW1iZXIoYmx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ29sb3IgdmFsdWUgc2hvdWxkIGJlIGluIEhFWCBmb3JtYXQuIFwiLmNvbmNhdChlcnJvcikpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzb2x2ZXIgPSBuZXcgU29sdmVyKGNvbG9yLCBPYmplY3QuYXNzaWduKHt9LCBcbiAgICAgICAgLy8gYEhleFRvQ3NzQ29uZmlndXJhdGlvbmAgRGVmYXVsdHNcbiAgICAgICAge1xuICAgICAgICAgICAgYWNjZXB0YW5jZUxvc3NQZXJjZW50YWdlOiA1LFxuICAgICAgICAgICAgbWF4Q2hlY2tzOiAzMCxcbiAgICAgICAgICAgIGZvcmNlRmlsdGVyUmVjYWxjdWxhdGlvbjogZmFsc2UsXG4gICAgICAgIH0sIG9wdHMpKTtcbiAgICAgICAgcmV0dXJuIChyZXN1bHRzW2NvbG9yVmFsdWVdID0gT2JqZWN0LmFzc2lnbih7fSwgc29sdmVyLnNvbHZlKCksIHtcbiAgICAgICAgICAgIGhleDogY29sb3JWYWx1ZSxcbiAgICAgICAgICAgIHJnYjogW3JlZCwgZ3JlZW4sIGJsdWVdLFxuICAgICAgICAgICAgY2FjaGU6IGZhbHNlLFxuICAgICAgICB9KSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBIGZ1bmN0aW9uIHRoYXQgY2xlYXJzIGNhY2hlZCByZXN1bHRzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gIHtzdHJpbmd9IGtleT8gSEVYIHN0cmluZyB2YWx1ZSBwYXNzZWQgcHJldmlvdXNseSBgIzI0NjM5Q2AuIElmIG5vdCBwYXNzZWQsIGl0IGNsZWFycyBhbGwgY2FjaGVkIHJlc3VsdHNcbiAgICAgKiBAcmV0dXJucyB2b2lkXG4gICAgICovXG4gICAgdmFyIGNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGlmICgha2V5KSB7XG4gICAgICAgICAgICByZXN1bHRzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzdWx0c1trZXldKSB7XG4gICAgICAgICAgICBkZWxldGUgcmVzdWx0c1trZXldO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGV4cG9ydHMuY2xlYXJDYWNoZSA9IGNsZWFyQ2FjaGU7XG4gICAgZXhwb3J0cy5oZXhUb0NTU0ZpbHRlciA9IGhleFRvQ1NTRmlsdGVyO1xuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxufSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/hex-to-css-filter/dist/umd/hex-to-css-filter.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/ui/MapNode.tsx":
/*!***********************************!*\
  !*** ./components/ui/MapNode.tsx ***!
  \***********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MapNode: function() { return /* binding */ MapNode; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_image__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/image */ \"(app-pages-browser)/./node_modules/next/dist/api/image.js\");\n/* harmony import */ var _public_BUBBLY_USER_svg__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../public/BUBBLY_USER.svg */ \"(app-pages-browser)/./public/BUBBLY_USER.svg\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var hex_to_css_filter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! hex-to-css-filter */ \"(app-pages-browser)/./node_modules/hex-to-css-filter/dist/umd/hex-to-css-filter.js\");\n/* harmony import */ var hex_to_css_filter__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(hex_to_css_filter__WEBPACK_IMPORTED_MODULE_4__);\n\nvar _s = $RefreshSig$();\n\n\n\n\n\nfunction MapNode(NodeProperties) {\n    _s();\n    var [showTrans, showOnClick] = react__WEBPACK_IMPORTED_MODULE_3___default().useState(false);\n    const XOFFSET = 256;\n    const YOFFSET = 256;\n    const scaleV = NodeProperties.scale ? NodeProperties.scale : 1;\n    'return `<div id=\"point-${id}\" style=\"background-color: ${fform_colors.get(id)};position: absolute;border-radius: 100px; border: 3px black solid;width: 25px;height: 25px;left: ${XOFFSET+x}px;top: ${YOFFSET-y}px;text-align: center;transform: rotate(${theta}deg);\"><div id=\"arr\" style=\"background-color: blue;width: 9px;height: 6px;left: 8px;position: relative;\"></div>${id}</div>`';\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: {\n            position: \"absolute\",\n            left: \"\".concat(XOFFSET + NodeProperties.x * scaleV, \"px\"),\n            top: \"\".concat(YOFFSET - NodeProperties.y * scaleV, \"px\"),\n            rotate: \"\".concat(NodeProperties.heading ? NodeProperties.heading - 90 : -90, \"deg\")\n        },\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                id: \"identifier\",\n                children: \"3\"\n            }, void 0, false, {\n                fileName: \"/Users/ktzhang/convo-sepper/components/ui/MapNode.tsx\",\n                lineNumber: 33,\n                columnNumber: 209\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(next_image__WEBPACK_IMPORTED_MODULE_1__[\"default\"], {\n                style: {\n                    filter: (0,hex_to_css_filter__WEBPACK_IMPORTED_MODULE_4__.hexToCSSFilter)(NodeProperties.colour).filter\n                },\n                src: _public_BUBBLY_USER_svg__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n                alt: \"bubbly\"\n            }, void 0, false, {\n                fileName: \"/Users/ktzhang/convo-sepper/components/ui/MapNode.tsx\",\n                lineNumber: 33,\n                columnNumber: 237\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"/Users/ktzhang/convo-sepper/components/ui/MapNode.tsx\",\n        lineNumber: 33,\n        columnNumber: 7\n    }, this);\n}\n_s(MapNode, \"kJDyEmayh0Gzh7NljP+kZtKdOZE=\");\n_c = MapNode;\nvar _c;\n$RefreshReg$(_c, \"MapNode\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvdWkvTWFwTm9kZS50c3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQW9CTUE7QUFuQndCO0FBRW9CO0FBR3hCO0FBQ3lCO0FBZTVDLFNBQVNLLFFBQVFDLGNBQXlCOztJQUMvQyxJQUFJLENBQUNDLFdBQVdDLFlBQVksR0FBR0wscURBQWMsQ0FBQztJQUVoRCxNQUFNTyxVQUFVO0lBQ2hCLE1BQU1DLFVBQVU7SUFFaEIsTUFBTUMsU0FBU04sZUFBZU8sS0FBSyxHQUFHUCxlQUFlTyxLQUFLLEdBQUc7SUFFM0Q7SUFDQSxxQkFDSSw4REFBQ0M7UUFBSUMsT0FBTztZQUFDQyxVQUFTO1lBQVlDLE1BQU0sR0FBbUMsT0FBaENQLFVBQVFKLGVBQWVZLENBQUMsR0FBQ04sUUFBTztZQUFLTyxLQUFLLEdBQW1DLE9BQWhDUixVQUFRTCxlQUFlYyxDQUFDLEdBQUNSLFFBQU87WUFBS1MsUUFBUSxHQUE4RCxPQUEzRGYsZUFBZWdCLE9BQU8sR0FBR2hCLGVBQWVnQixPQUFPLEdBQUcsS0FBSyxDQUFDLElBQUc7UUFBSTs7MEJBQUcsOERBQUNSO2dCQUFJUyxJQUFHOzBCQUFhOzs7Ozs7MEJBQU8sOERBQUN0QixrREFBS0E7Z0JBQUNjLE9BQU87b0JBQUNTLFFBQVFwQixpRUFBY0EsQ0FBQ0UsZUFBZW1CLE1BQU0sRUFBRUQsTUFBTTtnQkFBQTtnQkFBR0UsS0FBS3hCLCtEQUFNQTtnQkFBRXlCLEtBQUs7Ozs7Ozs7Ozs7OztBQUVwVTtHQVpnQnRCO0tBQUFBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvdWkvTWFwTm9kZS50c3g/MjM5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgTGluayBmcm9tIFwibmV4dC9saW5rXCI7XG5pbXBvcnQgSW1hZ2UgZnJvbSBcIm5leHQvaW1hZ2VcIlxuaW1wb3J0IHsgU3RhdGljSW1wb3J0IH0gZnJvbSBcIm5leHQvZGlzdC9zaGFyZWQvbGliL2dldC1pbWctcHJvcHNcIjtcbmltcG9ydCBCVUJCTFkgZnJvbSBcIi4uLy4uL3B1YmxpYy9CVUJCTFlfVVNFUi5zdmdcIjtcbmltcG9ydCB7IENTU1Byb3BlcnRpZXMgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IEludGVyIH0gZnJvbSBcIm5leHQvZm9udC9nb29nbGVcIjtcbmltcG9ydCBSZWFjdCBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCB7IGhleFRvQ1NTRmlsdGVyIH0gZnJvbSBcImhleC10by1jc3MtZmlsdGVyXCI7XG5cbmludGVyZmFjZSBOb2RlUHJvcHMge1xuICBjbGFzc05hbWU/OiBzdHJpbmc7XG4gIHBhdXNlZD86IGJvb2xlYW5cbiAgeDogbnVtYmVyLFxuICB5OiBudW1iZXIsXG4gIGhlYWRpbmc6IG51bWJlcixcbiAgTm9kZUlkOiBudW1iZXIsXG4gIGNvbG91cjogc3RyaW5nLFxuICBzY2FsZT86IG51bWJlclxufVxuXG5jb25zdCBpbnRlckYgPSBJbnRlcih7c3Vic2V0czpbJ2xhdGluJ119KVxuXG5leHBvcnQgZnVuY3Rpb24gTWFwTm9kZShOb2RlUHJvcGVydGllczogTm9kZVByb3BzKSB7XG4gIHZhciBbc2hvd1RyYW5zLCBzaG93T25DbGlja10gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG5cbmNvbnN0IFhPRkZTRVQgPSAyNTY7XG5jb25zdCBZT0ZGU0VUID0gMjU2O1xuXG5jb25zdCBzY2FsZVYgPSBOb2RlUHJvcGVydGllcy5zY2FsZSA/IE5vZGVQcm9wZXJ0aWVzLnNjYWxlIDogMVxuXG4gICdyZXR1cm4gYDxkaXYgaWQ9XCJwb2ludC0ke2lkfVwiIHN0eWxlPVwiYmFja2dyb3VuZC1jb2xvcjogJHtmZm9ybV9jb2xvcnMuZ2V0KGlkKX07cG9zaXRpb246IGFic29sdXRlO2JvcmRlci1yYWRpdXM6IDEwMHB4OyBib3JkZXI6IDNweCBibGFjayBzb2xpZDt3aWR0aDogMjVweDtoZWlnaHQ6IDI1cHg7bGVmdDogJHtYT0ZGU0VUK3h9cHg7dG9wOiAke1lPRkZTRVQteX1weDt0ZXh0LWFsaWduOiBjZW50ZXI7dHJhbnNmb3JtOiByb3RhdGUoJHt0aGV0YX1kZWcpO1wiPjxkaXYgaWQ9XCJhcnJcIiBzdHlsZT1cImJhY2tncm91bmQtY29sb3I6IGJsdWU7d2lkdGg6IDlweDtoZWlnaHQ6IDZweDtsZWZ0OiA4cHg7cG9zaXRpb246IHJlbGF0aXZlO1wiPjwvZGl2PiR7aWR9PC9kaXY+YCdcbiAgcmV0dXJuIChcbiAgICAgIDxkaXYgc3R5bGU9e3twb3NpdGlvbjpcImFic29sdXRlXCIsIGxlZnQ6IGAke1hPRkZTRVQrTm9kZVByb3BlcnRpZXMueCpzY2FsZVZ9cHhgLCB0b3A6IGAke1lPRkZTRVQtTm9kZVByb3BlcnRpZXMueSpzY2FsZVZ9cHhgLCByb3RhdGU6IGAke05vZGVQcm9wZXJ0aWVzLmhlYWRpbmcgPyBOb2RlUHJvcGVydGllcy5oZWFkaW5nIC0gOTAgOiAtOTB9ZGVnYH19PjxkaXYgaWQ9XCJpZGVudGlmaWVyXCI+MzwvZGl2PjxJbWFnZSBzdHlsZT17e2ZpbHRlcjogaGV4VG9DU1NGaWx0ZXIoTm9kZVByb3BlcnRpZXMuY29sb3VyKS5maWx0ZXJ9fSBzcmM9e0JVQkJMWX0gYWx0PXtcImJ1YmJseVwifT48L0ltYWdlPjwvZGl2PlxuICApO1xufSAiXSwibmFtZXMiOlsiaW50ZXJGIiwiSW1hZ2UiLCJCVUJCTFkiLCJSZWFjdCIsImhleFRvQ1NTRmlsdGVyIiwiTWFwTm9kZSIsIk5vZGVQcm9wZXJ0aWVzIiwic2hvd1RyYW5zIiwic2hvd09uQ2xpY2siLCJ1c2VTdGF0ZSIsIlhPRkZTRVQiLCJZT0ZGU0VUIiwic2NhbGVWIiwic2NhbGUiLCJkaXYiLCJzdHlsZSIsInBvc2l0aW9uIiwibGVmdCIsIngiLCJ0b3AiLCJ5Iiwicm90YXRlIiwiaGVhZGluZyIsImlkIiwiZmlsdGVyIiwiY29sb3VyIiwic3JjIiwiYWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/ui/MapNode.tsx\n"));

/***/ })

});