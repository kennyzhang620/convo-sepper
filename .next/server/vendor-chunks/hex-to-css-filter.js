"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/hex-to-css-filter";
exports.ids = ["vendor-chunks/hex-to-css-filter"];
exports.modules = {

/***/ "(ssr)/./node_modules/hex-to-css-filter/dist/esm/color.js":
/*!**********************************************************!*\
  !*** ./node_modules/hex-to-css-filter/dist/esm/color.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Color: () => (/* binding */ Color)\n/* harmony export */ });\nvar Color = /** @class */ (function () {\n    function Color(r, g, b) {\n        this.r = 0;\n        this.g = 0;\n        this.b = 0;\n        this.set(r, g, b);\n    }\n    Color.prototype.set = function (r, g, b) {\n        this.r = this.clamp(r);\n        this.g = this.clamp(g);\n        this.b = this.clamp(b);\n    };\n    /**\n     * Applying cals to get CSS filter for hue-rotate\n     *\n     * @param {number} [angle=0]\n     * @memberof Color\n     */\n    Color.prototype.hueRotate = function (angle) {\n        if (angle === void 0) { angle = 0; }\n        angle = (angle / 180) * Math.PI;\n        var sin = Math.sin(angle);\n        var cos = Math.cos(angle);\n        this.multiply([\n            0.213 + cos * 0.787 - sin * 0.213,\n            0.715 - cos * 0.715 - sin * 0.715,\n            0.072 - cos * 0.072 + sin * 0.928,\n            0.213 - cos * 0.213 + sin * 0.143,\n            0.715 + cos * 0.285 + sin * 0.14,\n            0.072 - cos * 0.072 - sin * 0.283,\n            0.213 - cos * 0.213 - sin * 0.787,\n            0.715 - cos * 0.715 + sin * 0.715,\n            0.072 + cos * 0.928 + sin * 0.072,\n        ]);\n    };\n    /**\n     * Applying cals to get CSS filter for grayscale\n     *\n     * @param {number} [value=1]\n     * @memberof Color\n     */\n    Color.prototype.grayscale = function (value) {\n        if (value === void 0) { value = 1; }\n        this.multiply([\n            0.2126 + 0.7874 * (1 - value),\n            0.7152 - 0.7152 * (1 - value),\n            0.0722 - 0.0722 * (1 - value),\n            0.2126 - 0.2126 * (1 - value),\n            0.7152 + 0.2848 * (1 - value),\n            0.0722 - 0.0722 * (1 - value),\n            0.2126 - 0.2126 * (1 - value),\n            0.7152 - 0.7152 * (1 - value),\n            0.0722 + 0.9278 * (1 - value),\n        ]);\n    };\n    /**\n     * Applying cals to get CSS filter for sepia\n     *\n     * @param {number} [value=1]\n     * @memberof Color\n     */\n    Color.prototype.sepia = function (value) {\n        if (value === void 0) { value = 1; }\n        this.multiply([\n            0.393 + 0.607 * (1 - value),\n            0.769 - 0.769 * (1 - value),\n            0.189 - 0.189 * (1 - value),\n            0.349 - 0.349 * (1 - value),\n            0.686 + 0.314 * (1 - value),\n            0.168 - 0.168 * (1 - value),\n            0.272 - 0.272 * (1 - value),\n            0.534 - 0.534 * (1 - value),\n            0.131 + 0.869 * (1 - value),\n        ]);\n    };\n    /**\n     * Applying cals to get CSS filter for saturate\n     *\n     * @param {number} [value=1]\n     * @memberof Color\n     */\n    Color.prototype.saturate = function (value) {\n        if (value === void 0) { value = 1; }\n        this.multiply([\n            0.213 + 0.787 * value,\n            0.715 - 0.715 * value,\n            0.072 - 0.072 * value,\n            0.213 - 0.213 * value,\n            0.715 + 0.285 * value,\n            0.072 - 0.072 * value,\n            0.213 - 0.213 * value,\n            0.715 - 0.715 * value,\n            0.072 + 0.928 * value,\n        ]);\n    };\n    Color.prototype.multiply = function (matrix) {\n        // These values are needed. It's correct because the returned values will change\n        var newR = this.clamp(this.r * matrix[0] + this.g * matrix[1] + this.b * matrix[2]);\n        var newG = this.clamp(this.r * matrix[3] + this.g * matrix[4] + this.b * matrix[5]);\n        var newB = this.clamp(this.r * matrix[6] + this.g * matrix[7] + this.b * matrix[8]);\n        this.r = newR;\n        this.g = newG;\n        this.b = newB;\n    };\n    /**\n     * Applying cals to get CSS filter for brightness\n     *\n     * @param {number} [value=1]\n     * @memberof Color\n     */\n    Color.prototype.brightness = function (value) {\n        if (value === void 0) { value = 1; }\n        this.linear(value);\n    };\n    /**\n     * Applying cals to get CSS filter for contrast\n     *\n     * @param {number} [value=1]\n     * @memberof Color\n     */\n    Color.prototype.contrast = function (value) {\n        if (value === void 0) { value = 1; }\n        this.linear(value, -(0.5 * value) + 0.5);\n    };\n    Color.prototype.linear = function (slope, intercept) {\n        if (slope === void 0) { slope = 1; }\n        if (intercept === void 0) { intercept = 0; }\n        this.r = this.clamp(this.r * slope + intercept * 255);\n        this.g = this.clamp(this.g * slope + intercept * 255);\n        this.b = this.clamp(this.b * slope + intercept * 255);\n    };\n    /**\n     * Applying cals to get CSS filter for invert\n     *\n     * @param {number} [value=1]\n     * @memberof Color\n     */\n    Color.prototype.invert = function (value) {\n        if (value === void 0) { value = 1; }\n        this.r = this.clamp((value + (this.r / 255) * (1 - 2 * value)) * 255);\n        this.g = this.clamp((value + (this.g / 255) * (1 - 2 * value)) * 255);\n        this.b = this.clamp((value + (this.b / 255) * (1 - 2 * value)) * 255);\n    };\n    /**\n     * transform RGB into HSL values\n     *\n     * @returns {HSLData}\n     * @memberof Color\n     */\n    Color.prototype.hsl = function () {\n        var red = this.r / 255;\n        var green = this.g / 255;\n        var blue = this.b / 255;\n        // find greatest and smallest channel values\n        var max = Math.max(red, green, blue);\n        var min = Math.min(red, green, blue);\n        var hue = 0;\n        var saturation = 0;\n        var lightness = (max + min) / 2;\n        // If min and max have the same values, it means\n        // the given color is achromatic\n        if (max === min) {\n            return {\n                h: 0,\n                s: 0,\n                l: lightness * 100,\n            };\n        }\n        // Adding delta value of greatest and smallest channel values\n        var delta = max - min;\n        saturation = lightness > 0.5 ? delta / (2 - max - min) : delta / (max + min);\n        if (max === red) {\n            hue = (green - blue) / delta + (green < blue ? 6 : 0);\n        }\n        else if (max === green) {\n            hue = (blue - red) / delta + 2;\n        }\n        else if (max === blue) {\n            hue = (red - green) / delta + 4;\n        }\n        hue /= 6;\n        return {\n            h: hue * 100,\n            s: saturation * 100,\n            l: lightness * 100,\n        };\n    };\n    /**\n     * Normalize the value to follow the min and max for RGB colors\n     * min: 0\n     * max: 255\n     *\n     * @private\n     * @param {number} value\n     * @returns {number}\n     * @memberof Color\n     */\n    Color.prototype.clamp = function (value) {\n        // Minimum RGB Value = 0;\n        // Maximum RGB Value = 255;\n        return Math.min(Math.max(value, 0), 255);\n    };\n    return Color;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGV4LXRvLWNzcy1maWx0ZXIvZGlzdC9lc20vY29sb3IuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEMsb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9zY2llbmNld29ybGQtYXItcmVhY3QvLi9ub2RlX21vZHVsZXMvaGV4LXRvLWNzcy1maWx0ZXIvZGlzdC9lc20vY29sb3IuanM/ZmI5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgQ29sb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ29sb3IociwgZywgYikge1xuICAgICAgICB0aGlzLnIgPSAwO1xuICAgICAgICB0aGlzLmcgPSAwO1xuICAgICAgICB0aGlzLmIgPSAwO1xuICAgICAgICB0aGlzLnNldChyLCBnLCBiKTtcbiAgICB9XG4gICAgQ29sb3IucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChyLCBnLCBiKSB7XG4gICAgICAgIHRoaXMuciA9IHRoaXMuY2xhbXAocik7XG4gICAgICAgIHRoaXMuZyA9IHRoaXMuY2xhbXAoZyk7XG4gICAgICAgIHRoaXMuYiA9IHRoaXMuY2xhbXAoYik7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBseWluZyBjYWxzIHRvIGdldCBDU1MgZmlsdGVyIGZvciBodWUtcm90YXRlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FuZ2xlPTBdXG4gICAgICogQG1lbWJlcm9mIENvbG9yXG4gICAgICovXG4gICAgQ29sb3IucHJvdG90eXBlLmh1ZVJvdGF0ZSA9IGZ1bmN0aW9uIChhbmdsZSkge1xuICAgICAgICBpZiAoYW5nbGUgPT09IHZvaWQgMCkgeyBhbmdsZSA9IDA7IH1cbiAgICAgICAgYW5nbGUgPSAoYW5nbGUgLyAxODApICogTWF0aC5QSTtcbiAgICAgICAgdmFyIHNpbiA9IE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgdmFyIGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgdGhpcy5tdWx0aXBseShbXG4gICAgICAgICAgICAwLjIxMyArIGNvcyAqIDAuNzg3IC0gc2luICogMC4yMTMsXG4gICAgICAgICAgICAwLjcxNSAtIGNvcyAqIDAuNzE1IC0gc2luICogMC43MTUsXG4gICAgICAgICAgICAwLjA3MiAtIGNvcyAqIDAuMDcyICsgc2luICogMC45MjgsXG4gICAgICAgICAgICAwLjIxMyAtIGNvcyAqIDAuMjEzICsgc2luICogMC4xNDMsXG4gICAgICAgICAgICAwLjcxNSArIGNvcyAqIDAuMjg1ICsgc2luICogMC4xNCxcbiAgICAgICAgICAgIDAuMDcyIC0gY29zICogMC4wNzIgLSBzaW4gKiAwLjI4MyxcbiAgICAgICAgICAgIDAuMjEzIC0gY29zICogMC4yMTMgLSBzaW4gKiAwLjc4NyxcbiAgICAgICAgICAgIDAuNzE1IC0gY29zICogMC43MTUgKyBzaW4gKiAwLjcxNSxcbiAgICAgICAgICAgIDAuMDcyICsgY29zICogMC45MjggKyBzaW4gKiAwLjA3MixcbiAgICAgICAgXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBseWluZyBjYWxzIHRvIGdldCBDU1MgZmlsdGVyIGZvciBncmF5c2NhbGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmFsdWU9MV1cbiAgICAgKiBAbWVtYmVyb2YgQ29sb3JcbiAgICAgKi9cbiAgICBDb2xvci5wcm90b3R5cGUuZ3JheXNjYWxlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gMTsgfVxuICAgICAgICB0aGlzLm11bHRpcGx5KFtcbiAgICAgICAgICAgIDAuMjEyNiArIDAuNzg3NCAqICgxIC0gdmFsdWUpLFxuICAgICAgICAgICAgMC43MTUyIC0gMC43MTUyICogKDEgLSB2YWx1ZSksXG4gICAgICAgICAgICAwLjA3MjIgLSAwLjA3MjIgKiAoMSAtIHZhbHVlKSxcbiAgICAgICAgICAgIDAuMjEyNiAtIDAuMjEyNiAqICgxIC0gdmFsdWUpLFxuICAgICAgICAgICAgMC43MTUyICsgMC4yODQ4ICogKDEgLSB2YWx1ZSksXG4gICAgICAgICAgICAwLjA3MjIgLSAwLjA3MjIgKiAoMSAtIHZhbHVlKSxcbiAgICAgICAgICAgIDAuMjEyNiAtIDAuMjEyNiAqICgxIC0gdmFsdWUpLFxuICAgICAgICAgICAgMC43MTUyIC0gMC43MTUyICogKDEgLSB2YWx1ZSksXG4gICAgICAgICAgICAwLjA3MjIgKyAwLjkyNzggKiAoMSAtIHZhbHVlKSxcbiAgICAgICAgXSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBseWluZyBjYWxzIHRvIGdldCBDU1MgZmlsdGVyIGZvciBzZXBpYVxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt2YWx1ZT0xXVxuICAgICAqIEBtZW1iZXJvZiBDb2xvclxuICAgICAqL1xuICAgIENvbG9yLnByb3RvdHlwZS5zZXBpYSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IDE7IH1cbiAgICAgICAgdGhpcy5tdWx0aXBseShbXG4gICAgICAgICAgICAwLjM5MyArIDAuNjA3ICogKDEgLSB2YWx1ZSksXG4gICAgICAgICAgICAwLjc2OSAtIDAuNzY5ICogKDEgLSB2YWx1ZSksXG4gICAgICAgICAgICAwLjE4OSAtIDAuMTg5ICogKDEgLSB2YWx1ZSksXG4gICAgICAgICAgICAwLjM0OSAtIDAuMzQ5ICogKDEgLSB2YWx1ZSksXG4gICAgICAgICAgICAwLjY4NiArIDAuMzE0ICogKDEgLSB2YWx1ZSksXG4gICAgICAgICAgICAwLjE2OCAtIDAuMTY4ICogKDEgLSB2YWx1ZSksXG4gICAgICAgICAgICAwLjI3MiAtIDAuMjcyICogKDEgLSB2YWx1ZSksXG4gICAgICAgICAgICAwLjUzNCAtIDAuNTM0ICogKDEgLSB2YWx1ZSksXG4gICAgICAgICAgICAwLjEzMSArIDAuODY5ICogKDEgLSB2YWx1ZSksXG4gICAgICAgIF0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwbHlpbmcgY2FscyB0byBnZXQgQ1NTIGZpbHRlciBmb3Igc2F0dXJhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmFsdWU9MV1cbiAgICAgKiBAbWVtYmVyb2YgQ29sb3JcbiAgICAgKi9cbiAgICBDb2xvci5wcm90b3R5cGUuc2F0dXJhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSAxOyB9XG4gICAgICAgIHRoaXMubXVsdGlwbHkoW1xuICAgICAgICAgICAgMC4yMTMgKyAwLjc4NyAqIHZhbHVlLFxuICAgICAgICAgICAgMC43MTUgLSAwLjcxNSAqIHZhbHVlLFxuICAgICAgICAgICAgMC4wNzIgLSAwLjA3MiAqIHZhbHVlLFxuICAgICAgICAgICAgMC4yMTMgLSAwLjIxMyAqIHZhbHVlLFxuICAgICAgICAgICAgMC43MTUgKyAwLjI4NSAqIHZhbHVlLFxuICAgICAgICAgICAgMC4wNzIgLSAwLjA3MiAqIHZhbHVlLFxuICAgICAgICAgICAgMC4yMTMgLSAwLjIxMyAqIHZhbHVlLFxuICAgICAgICAgICAgMC43MTUgLSAwLjcxNSAqIHZhbHVlLFxuICAgICAgICAgICAgMC4wNzIgKyAwLjkyOCAqIHZhbHVlLFxuICAgICAgICBdKTtcbiAgICB9O1xuICAgIENvbG9yLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uIChtYXRyaXgpIHtcbiAgICAgICAgLy8gVGhlc2UgdmFsdWVzIGFyZSBuZWVkZWQuIEl0J3MgY29ycmVjdCBiZWNhdXNlIHRoZSByZXR1cm5lZCB2YWx1ZXMgd2lsbCBjaGFuZ2VcbiAgICAgICAgdmFyIG5ld1IgPSB0aGlzLmNsYW1wKHRoaXMuciAqIG1hdHJpeFswXSArIHRoaXMuZyAqIG1hdHJpeFsxXSArIHRoaXMuYiAqIG1hdHJpeFsyXSk7XG4gICAgICAgIHZhciBuZXdHID0gdGhpcy5jbGFtcCh0aGlzLnIgKiBtYXRyaXhbM10gKyB0aGlzLmcgKiBtYXRyaXhbNF0gKyB0aGlzLmIgKiBtYXRyaXhbNV0pO1xuICAgICAgICB2YXIgbmV3QiA9IHRoaXMuY2xhbXAodGhpcy5yICogbWF0cml4WzZdICsgdGhpcy5nICogbWF0cml4WzddICsgdGhpcy5iICogbWF0cml4WzhdKTtcbiAgICAgICAgdGhpcy5yID0gbmV3UjtcbiAgICAgICAgdGhpcy5nID0gbmV3RztcbiAgICAgICAgdGhpcy5iID0gbmV3QjtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEFwcGx5aW5nIGNhbHMgdG8gZ2V0IENTUyBmaWx0ZXIgZm9yIGJyaWdodG5lc3NcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmFsdWU9MV1cbiAgICAgKiBAbWVtYmVyb2YgQ29sb3JcbiAgICAgKi9cbiAgICBDb2xvci5wcm90b3R5cGUuYnJpZ2h0bmVzcyA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkgeyB2YWx1ZSA9IDE7IH1cbiAgICAgICAgdGhpcy5saW5lYXIodmFsdWUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXBwbHlpbmcgY2FscyB0byBnZXQgQ1NTIGZpbHRlciBmb3IgY29udHJhc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmFsdWU9MV1cbiAgICAgKiBAbWVtYmVyb2YgQ29sb3JcbiAgICAgKi9cbiAgICBDb2xvci5wcm90b3R5cGUuY29udHJhc3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHsgdmFsdWUgPSAxOyB9XG4gICAgICAgIHRoaXMubGluZWFyKHZhbHVlLCAtKDAuNSAqIHZhbHVlKSArIDAuNSk7XG4gICAgfTtcbiAgICBDb2xvci5wcm90b3R5cGUubGluZWFyID0gZnVuY3Rpb24gKHNsb3BlLCBpbnRlcmNlcHQpIHtcbiAgICAgICAgaWYgKHNsb3BlID09PSB2b2lkIDApIHsgc2xvcGUgPSAxOyB9XG4gICAgICAgIGlmIChpbnRlcmNlcHQgPT09IHZvaWQgMCkgeyBpbnRlcmNlcHQgPSAwOyB9XG4gICAgICAgIHRoaXMuciA9IHRoaXMuY2xhbXAodGhpcy5yICogc2xvcGUgKyBpbnRlcmNlcHQgKiAyNTUpO1xuICAgICAgICB0aGlzLmcgPSB0aGlzLmNsYW1wKHRoaXMuZyAqIHNsb3BlICsgaW50ZXJjZXB0ICogMjU1KTtcbiAgICAgICAgdGhpcy5iID0gdGhpcy5jbGFtcCh0aGlzLmIgKiBzbG9wZSArIGludGVyY2VwdCAqIDI1NSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBBcHBseWluZyBjYWxzIHRvIGdldCBDU1MgZmlsdGVyIGZvciBpbnZlcnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbdmFsdWU9MV1cbiAgICAgKiBAbWVtYmVyb2YgQ29sb3JcbiAgICAgKi9cbiAgICBDb2xvci5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdm9pZCAwKSB7IHZhbHVlID0gMTsgfVxuICAgICAgICB0aGlzLnIgPSB0aGlzLmNsYW1wKCh2YWx1ZSArICh0aGlzLnIgLyAyNTUpICogKDEgLSAyICogdmFsdWUpKSAqIDI1NSk7XG4gICAgICAgIHRoaXMuZyA9IHRoaXMuY2xhbXAoKHZhbHVlICsgKHRoaXMuZyAvIDI1NSkgKiAoMSAtIDIgKiB2YWx1ZSkpICogMjU1KTtcbiAgICAgICAgdGhpcy5iID0gdGhpcy5jbGFtcCgodmFsdWUgKyAodGhpcy5iIC8gMjU1KSAqICgxIC0gMiAqIHZhbHVlKSkgKiAyNTUpO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogdHJhbnNmb3JtIFJHQiBpbnRvIEhTTCB2YWx1ZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtIU0xEYXRhfVxuICAgICAqIEBtZW1iZXJvZiBDb2xvclxuICAgICAqL1xuICAgIENvbG9yLnByb3RvdHlwZS5oc2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZWQgPSB0aGlzLnIgLyAyNTU7XG4gICAgICAgIHZhciBncmVlbiA9IHRoaXMuZyAvIDI1NTtcbiAgICAgICAgdmFyIGJsdWUgPSB0aGlzLmIgLyAyNTU7XG4gICAgICAgIC8vIGZpbmQgZ3JlYXRlc3QgYW5kIHNtYWxsZXN0IGNoYW5uZWwgdmFsdWVzXG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heChyZWQsIGdyZWVuLCBibHVlKTtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHJlZCwgZ3JlZW4sIGJsdWUpO1xuICAgICAgICB2YXIgaHVlID0gMDtcbiAgICAgICAgdmFyIHNhdHVyYXRpb24gPSAwO1xuICAgICAgICB2YXIgbGlnaHRuZXNzID0gKG1heCArIG1pbikgLyAyO1xuICAgICAgICAvLyBJZiBtaW4gYW5kIG1heCBoYXZlIHRoZSBzYW1lIHZhbHVlcywgaXQgbWVhbnNcbiAgICAgICAgLy8gdGhlIGdpdmVuIGNvbG9yIGlzIGFjaHJvbWF0aWNcbiAgICAgICAgaWYgKG1heCA9PT0gbWluKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGg6IDAsXG4gICAgICAgICAgICAgICAgczogMCxcbiAgICAgICAgICAgICAgICBsOiBsaWdodG5lc3MgKiAxMDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIEFkZGluZyBkZWx0YSB2YWx1ZSBvZiBncmVhdGVzdCBhbmQgc21hbGxlc3QgY2hhbm5lbCB2YWx1ZXNcbiAgICAgICAgdmFyIGRlbHRhID0gbWF4IC0gbWluO1xuICAgICAgICBzYXR1cmF0aW9uID0gbGlnaHRuZXNzID4gMC41ID8gZGVsdGEgLyAoMiAtIG1heCAtIG1pbikgOiBkZWx0YSAvIChtYXggKyBtaW4pO1xuICAgICAgICBpZiAobWF4ID09PSByZWQpIHtcbiAgICAgICAgICAgIGh1ZSA9IChncmVlbiAtIGJsdWUpIC8gZGVsdGEgKyAoZ3JlZW4gPCBibHVlID8gNiA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG1heCA9PT0gZ3JlZW4pIHtcbiAgICAgICAgICAgIGh1ZSA9IChibHVlIC0gcmVkKSAvIGRlbHRhICsgMjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChtYXggPT09IGJsdWUpIHtcbiAgICAgICAgICAgIGh1ZSA9IChyZWQgLSBncmVlbikgLyBkZWx0YSArIDQ7XG4gICAgICAgIH1cbiAgICAgICAgaHVlIC89IDY7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoOiBodWUgKiAxMDAsXG4gICAgICAgICAgICBzOiBzYXR1cmF0aW9uICogMTAwLFxuICAgICAgICAgICAgbDogbGlnaHRuZXNzICogMTAwLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogTm9ybWFsaXplIHRoZSB2YWx1ZSB0byBmb2xsb3cgdGhlIG1pbiBhbmQgbWF4IGZvciBSR0IgY29sb3JzXG4gICAgICogbWluOiAwXG4gICAgICogbWF4OiAyNTVcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgQ29sb3JcbiAgICAgKi9cbiAgICBDb2xvci5wcm90b3R5cGUuY2xhbXAgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgLy8gTWluaW11bSBSR0IgVmFsdWUgPSAwO1xuICAgICAgICAvLyBNYXhpbXVtIFJHQiBWYWx1ZSA9IDI1NTtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KHZhbHVlLCAwKSwgMjU1KTtcbiAgICB9O1xuICAgIHJldHVybiBDb2xvcjtcbn0oKSk7XG5leHBvcnQgeyBDb2xvciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hex-to-css-filter/dist/esm/color.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/hex-to-css-filter/dist/esm/hex-to-css-filter.js":
/*!**********************************************************************!*\
  !*** ./node_modules/hex-to-css-filter/dist/esm/hex-to-css-filter.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearCache: () => (/* binding */ clearCache),\n/* harmony export */   hexToCSSFilter: () => (/* binding */ hexToCSSFilter)\n/* harmony export */ });\n/* harmony import */ var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! tslib */ \"(ssr)/./node_modules/tslib/tslib.es6.mjs\");\n/* harmony import */ var _solver__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./solver */ \"(ssr)/./node_modules/hex-to-css-filter/dist/esm/solver.js\");\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./color */ \"(ssr)/./node_modules/hex-to-css-filter/dist/esm/color.js\");\n\n\n\n/**\n * Transform a CSS Color from Hexadecimal to RGB color\n *\n * @param {string} hex hexadecimal color\n * @returns {([number, number, number] | [])} array with the RGB colors or empty array\n */\nvar hexToRgb = function (hex) {\n    if (hex.length === 4) {\n        return [parseInt(\"0x\".concat(hex[1]).concat(hex[1])), parseInt(\"0x\".concat(hex[2]).concat(hex[2])), parseInt(\"0x\".concat(hex[3]).concat(hex[3]))];\n    }\n    if (hex.length === 7) {\n        return [parseInt(\"0x\".concat(hex[1]).concat(hex[2])), parseInt(\"0x\".concat(hex[3]).concat(hex[4])), parseInt(\"0x\".concat(hex[5]).concat(hex[6]))];\n    }\n    return [];\n};\nvar isNumeric = function (n) { return !isNaN(parseFloat(n)) && isFinite(n); };\n// Memory cache for the computed results to avoid multiple\n// calculations for the same color\nvar results = {};\n/**\n * A function that transforms a HEX color into CSS filters\n *\n * @param colorValue string hexadecimal color\n * @param opts HexToCssConfiguration function configuration\n *\n */\nvar hexToCSSFilter = function (colorValue, opts) {\n    var _a;\n    if (opts === void 0) { opts = {}; }\n    var red;\n    var green;\n    var blue;\n    if (results[colorValue] && !opts.forceFilterRecalculation) {\n        return Object.assign({}, results[colorValue], { cache: true });\n    }\n    var color;\n    try {\n        _a = (0,tslib__WEBPACK_IMPORTED_MODULE_0__.__read)(hexToRgb(colorValue), 3), red = _a[0], green = _a[1], blue = _a[2];\n        if (!isNumeric(red) || !isNumeric(green) || !isNumeric(blue)) {\n            throw new Error(\"hextToRgb returned an invalid value for '\".concat(colorValue, \"'\"));\n        }\n        color = new _color__WEBPACK_IMPORTED_MODULE_1__.Color(Number(red), Number(green), Number(blue));\n    }\n    catch (error) {\n        throw new Error(\"Color value should be in HEX format. \".concat(error));\n    }\n    var solver = new _solver__WEBPACK_IMPORTED_MODULE_2__.Solver(color, Object.assign({}, \n    // `HexToCssConfiguration` Defaults\n    {\n        acceptanceLossPercentage: 5,\n        maxChecks: 30,\n        forceFilterRecalculation: false,\n    }, opts));\n    return (results[colorValue] = Object.assign({}, solver.solve(), {\n        hex: colorValue,\n        rgb: [red, green, blue],\n        cache: false,\n    }));\n};\n/**\n * A function that clears cached results\n *\n * @param  {string} key? HEX string value passed previously `#24639C`. If not passed, it clears all cached results\n * @returns void\n */\nvar clearCache = function (key) {\n    if (!key) {\n        results = {};\n    }\n    else if (results[key]) {\n        delete results[key];\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGV4LXRvLWNzcy1maWx0ZXIvZGlzdC9lc20vaGV4LXRvLWNzcy1maWx0ZXIuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBK0I7QUFDRztBQUNGO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhLGlDQUFpQztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IseUJBQXlCLGFBQWE7QUFDckU7QUFDQTtBQUNBO0FBQ0EsYUFBYSw2Q0FBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IseUNBQUs7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsMkNBQU0sd0JBQXdCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3NjaWVuY2V3b3JsZC1hci1yZWFjdC8uL25vZGVfbW9kdWxlcy9oZXgtdG8tY3NzLWZpbHRlci9kaXN0L2VzbS9oZXgtdG8tY3NzLWZpbHRlci5qcz9jMmEyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9fcmVhZCB9IGZyb20gXCJ0c2xpYlwiO1xuaW1wb3J0IHsgU29sdmVyIH0gZnJvbSAnLi9zb2x2ZXInO1xuaW1wb3J0IHsgQ29sb3IgfSBmcm9tICcuL2NvbG9yJztcbi8qKlxuICogVHJhbnNmb3JtIGEgQ1NTIENvbG9yIGZyb20gSGV4YWRlY2ltYWwgdG8gUkdCIGNvbG9yXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGhleCBoZXhhZGVjaW1hbCBjb2xvclxuICogQHJldHVybnMgeyhbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gfCBbXSl9IGFycmF5IHdpdGggdGhlIFJHQiBjb2xvcnMgb3IgZW1wdHkgYXJyYXlcbiAqL1xudmFyIGhleFRvUmdiID0gZnVuY3Rpb24gKGhleCkge1xuICAgIGlmIChoZXgubGVuZ3RoID09PSA0KSB7XG4gICAgICAgIHJldHVybiBbcGFyc2VJbnQoXCIweFwiLmNvbmNhdChoZXhbMV0pLmNvbmNhdChoZXhbMV0pKSwgcGFyc2VJbnQoXCIweFwiLmNvbmNhdChoZXhbMl0pLmNvbmNhdChoZXhbMl0pKSwgcGFyc2VJbnQoXCIweFwiLmNvbmNhdChoZXhbM10pLmNvbmNhdChoZXhbM10pKV07XG4gICAgfVxuICAgIGlmIChoZXgubGVuZ3RoID09PSA3KSB7XG4gICAgICAgIHJldHVybiBbcGFyc2VJbnQoXCIweFwiLmNvbmNhdChoZXhbMV0pLmNvbmNhdChoZXhbMl0pKSwgcGFyc2VJbnQoXCIweFwiLmNvbmNhdChoZXhbM10pLmNvbmNhdChoZXhbNF0pKSwgcGFyc2VJbnQoXCIweFwiLmNvbmNhdChoZXhbNV0pLmNvbmNhdChoZXhbNl0pKV07XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn07XG52YXIgaXNOdW1lcmljID0gZnVuY3Rpb24gKG4pIHsgcmV0dXJuICFpc05hTihwYXJzZUZsb2F0KG4pKSAmJiBpc0Zpbml0ZShuKTsgfTtcbi8vIE1lbW9yeSBjYWNoZSBmb3IgdGhlIGNvbXB1dGVkIHJlc3VsdHMgdG8gYXZvaWQgbXVsdGlwbGVcbi8vIGNhbGN1bGF0aW9ucyBmb3IgdGhlIHNhbWUgY29sb3JcbnZhciByZXN1bHRzID0ge307XG4vKipcbiAqIEEgZnVuY3Rpb24gdGhhdCB0cmFuc2Zvcm1zIGEgSEVYIGNvbG9yIGludG8gQ1NTIGZpbHRlcnNcbiAqXG4gKiBAcGFyYW0gY29sb3JWYWx1ZSBzdHJpbmcgaGV4YWRlY2ltYWwgY29sb3JcbiAqIEBwYXJhbSBvcHRzIEhleFRvQ3NzQ29uZmlndXJhdGlvbiBmdW5jdGlvbiBjb25maWd1cmF0aW9uXG4gKlxuICovXG5leHBvcnQgdmFyIGhleFRvQ1NTRmlsdGVyID0gZnVuY3Rpb24gKGNvbG9yVmFsdWUsIG9wdHMpIHtcbiAgICB2YXIgX2E7XG4gICAgaWYgKG9wdHMgPT09IHZvaWQgMCkgeyBvcHRzID0ge307IH1cbiAgICB2YXIgcmVkO1xuICAgIHZhciBncmVlbjtcbiAgICB2YXIgYmx1ZTtcbiAgICBpZiAocmVzdWx0c1tjb2xvclZhbHVlXSAmJiAhb3B0cy5mb3JjZUZpbHRlclJlY2FsY3VsYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlc3VsdHNbY29sb3JWYWx1ZV0sIHsgY2FjaGU6IHRydWUgfSk7XG4gICAgfVxuICAgIHZhciBjb2xvcjtcbiAgICB0cnkge1xuICAgICAgICBfYSA9IF9fcmVhZChoZXhUb1JnYihjb2xvclZhbHVlKSwgMyksIHJlZCA9IF9hWzBdLCBncmVlbiA9IF9hWzFdLCBibHVlID0gX2FbMl07XG4gICAgICAgIGlmICghaXNOdW1lcmljKHJlZCkgfHwgIWlzTnVtZXJpYyhncmVlbikgfHwgIWlzTnVtZXJpYyhibHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaGV4dFRvUmdiIHJldHVybmVkIGFuIGludmFsaWQgdmFsdWUgZm9yICdcIi5jb25jYXQoY29sb3JWYWx1ZSwgXCInXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBjb2xvciA9IG5ldyBDb2xvcihOdW1iZXIocmVkKSwgTnVtYmVyKGdyZWVuKSwgTnVtYmVyKGJsdWUpKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvbG9yIHZhbHVlIHNob3VsZCBiZSBpbiBIRVggZm9ybWF0LiBcIi5jb25jYXQoZXJyb3IpKTtcbiAgICB9XG4gICAgdmFyIHNvbHZlciA9IG5ldyBTb2x2ZXIoY29sb3IsIE9iamVjdC5hc3NpZ24oe30sIFxuICAgIC8vIGBIZXhUb0Nzc0NvbmZpZ3VyYXRpb25gIERlZmF1bHRzXG4gICAge1xuICAgICAgICBhY2NlcHRhbmNlTG9zc1BlcmNlbnRhZ2U6IDUsXG4gICAgICAgIG1heENoZWNrczogMzAsXG4gICAgICAgIGZvcmNlRmlsdGVyUmVjYWxjdWxhdGlvbjogZmFsc2UsXG4gICAgfSwgb3B0cykpO1xuICAgIHJldHVybiAocmVzdWx0c1tjb2xvclZhbHVlXSA9IE9iamVjdC5hc3NpZ24oe30sIHNvbHZlci5zb2x2ZSgpLCB7XG4gICAgICAgIGhleDogY29sb3JWYWx1ZSxcbiAgICAgICAgcmdiOiBbcmVkLCBncmVlbiwgYmx1ZV0sXG4gICAgICAgIGNhY2hlOiBmYWxzZSxcbiAgICB9KSk7XG59O1xuLyoqXG4gKiBBIGZ1bmN0aW9uIHRoYXQgY2xlYXJzIGNhY2hlZCByZXN1bHRzXG4gKlxuICogQHBhcmFtICB7c3RyaW5nfSBrZXk/IEhFWCBzdHJpbmcgdmFsdWUgcGFzc2VkIHByZXZpb3VzbHkgYCMyNDYzOUNgLiBJZiBub3QgcGFzc2VkLCBpdCBjbGVhcnMgYWxsIGNhY2hlZCByZXN1bHRzXG4gKiBAcmV0dXJucyB2b2lkXG4gKi9cbmV4cG9ydCB2YXIgY2xlYXJDYWNoZSA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIWtleSkge1xuICAgICAgICByZXN1bHRzID0ge307XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlc3VsdHNba2V5XSkge1xuICAgICAgICBkZWxldGUgcmVzdWx0c1trZXldO1xuICAgIH1cbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hex-to-css-filter/dist/esm/hex-to-css-filter.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/hex-to-css-filter/dist/esm/solver.js":
/*!***********************************************************!*\
  !*** ./node_modules/hex-to-css-filter/dist/esm/solver.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Solver: () => (/* binding */ Solver)\n/* harmony export */ });\n/* harmony import */ var _color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./color */ \"(ssr)/./node_modules/hex-to-css-filter/dist/esm/color.js\");\n\nvar Solver = /** @class */ (function () {\n    function Solver(target, options) {\n        this.target = target;\n        this.targetHSL = target.hsl();\n        this.options = Object.assign({}, \n        // Adding default values for options\n        {\n            acceptanceLossPercentage: 5,\n            maxChecks: 15,\n        }, options);\n        // All the calcs done by the library to generate\n        // a CSS Filter are based on the color `#000`\n        // in this case, `rgb(0, 0, 0)`\n        // Please make sure the background of the element\n        // is `#000` for better performance\n        // and color similarity.\n        this.reusedColor = new _color__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0);\n    }\n    /**\n     * Returns the solved values for the\n     *\n     * @returns {(SPSAPayload & { filter: string; })}\n     * @memberof Solver\n     */\n    Solver.prototype.solve = function () {\n        var result = this.solveNarrow(this.solveWide());\n        return {\n            values: result.values,\n            called: result.called,\n            loss: result.loss,\n            filter: this.css(result.values),\n        };\n    };\n    /**\n     * Solve wide values based on the wide values for RGB and HSL values\n     *\n     * @private\n     * @returns {SPSAPayload}\n     * @memberof Solver\n     */\n    Solver.prototype.solveWide = function () {\n        var A = 5;\n        var c = 15;\n        // Wide values for RGB and HSL values\n        // the values in the order: [`r`, `g`, `b`, `h`, `s`, `l`]\n        var a = [60, 180, 18000, 600, 1.2, 1.2];\n        var best = { loss: Infinity };\n        var counter = 0;\n        while (best.loss > this.options.acceptanceLossPercentage) {\n            var initialFilterValues = [50, 20, 3750, 50, 100, 100];\n            var result = this.spsa({\n                A: A,\n                a: a,\n                c: c,\n                values: initialFilterValues,\n                // for wide values we should use the double of tries in\n                // comparison of `solveNarrow()` method\n                maxTriesInLoop: 1000,\n            });\n            if (result.loss < best.loss) {\n                best = result;\n            }\n            counter += 1;\n            if (counter >= this.options.maxChecks) {\n                break;\n            }\n        }\n        return Object.assign({}, best, { called: counter });\n    };\n    /**\n     * Solve narrow values based on the wide values for the filter\n     *\n     * @private\n     * @param {SPSAPayload} wide\n     * @returns {SPSAPayload}\n     * @memberof Solver\n     */\n    Solver.prototype.solveNarrow = function (wide) {\n        var A = wide.loss;\n        var c = 2;\n        var A1 = A + 1;\n        // Narrow values for RGB and HSL values\n        // the values in the order: [`r`, `g`, `b`, `h`, `s`, `l`]\n        var a = [0.25 * A1, 0.25 * A1, A1, 0.25 * A1, 0.2 * A1, 0.2 * A1];\n        return this.spsa({\n            A: A,\n            a: a,\n            c: c,\n            values: wide.values,\n            maxTriesInLoop: 500,\n            called: wide.called,\n        });\n    };\n    /**\n     * Returns final value based on the current filter order\n     * to get the order, please check the returned value\n     * in `css()` method\n     *\n     * @private\n     * @param {number} value\n     * @param {number} idx\n     * @returns {number}\n     * @memberof Solver\n     */\n    Solver.prototype.fixValueByFilterIDX = function (value, idx) {\n        var max = 100;\n        // Fixing max, minimum and value by filter\n        if (idx === 2 /* saturate */) {\n            max = 7500;\n        }\n        else if (idx === 4 /* brightness */ || idx === 5 /* contrast */) {\n            max = 200;\n        }\n        if (idx === 3 /* hue-rotate */) {\n            if (value > max) {\n                value %= max;\n            }\n            else if (value < 0) {\n                value = max + (value % max);\n            }\n        }\n        // Checking if value is below the minimum or above\n        // the maximum allowed by filter\n        else if (value < 0) {\n            value = 0;\n        }\n        else if (value > max) {\n            value = max;\n        }\n        return value;\n    };\n    Solver.prototype.spsa = function (_a) {\n        var A = _a.A, a = _a.a, c = _a.c, values = _a.values, _b = _a.maxTriesInLoop, maxTriesInLoop = _b === void 0 ? 500 : _b, _c = _a.called, called = _c === void 0 ? 0 : _c;\n        var alpha = 1;\n        var gamma = 0.16666666666666666;\n        var best = null;\n        var bestLoss = Infinity;\n        var deltas = new Array(6);\n        var highArgs = new Array(6);\n        var lowArgs = new Array(6);\n        // Size of all CSS filters to be applied to get the correct color\n        var filtersToBeAppliedSize = 6;\n        for (var key = 0; key < maxTriesInLoop; key++) {\n            var ck = c / Math.pow(key + 1, gamma);\n            for (var i = 0; i < filtersToBeAppliedSize; i++) {\n                deltas[i] = Math.random() > 0.5 ? 1 : -1;\n                highArgs[i] = values[i] + ck * deltas[i];\n                lowArgs[i] = values[i] - ck * deltas[i];\n            }\n            var lossDiff = this.loss(highArgs) - this.loss(lowArgs);\n            for (var i = 0; i < filtersToBeAppliedSize; i++) {\n                var g = (lossDiff / (2 * ck)) * deltas[i];\n                var ak = a[i] / Math.pow(A + key + 1, alpha);\n                values[i] = this.fixValueByFilterIDX(values[i] - ak * g, i);\n            }\n            var loss = this.loss(values);\n            if (loss < bestLoss) {\n                best = values.slice(0);\n                bestLoss = loss;\n            }\n        }\n        return { values: best, loss: bestLoss, called: called };\n    };\n    /**\n     * Checks how much is the loss for the filter in RGB and HSL colors\n     *\n     * @private\n     * @param {SPSAPayload['values']} filters\n     * @returns {number}\n     * @memberof Solver\n     */\n    Solver.prototype.loss = function (filters) {\n        // Argument as an Array of percentages.\n        var color = this.reusedColor;\n        // Resetting the color to black in case\n        // it was called more than once\n        color.set(0, 0, 0);\n        color.invert(filters[0] / 100);\n        color.sepia(filters[1] / 100);\n        color.saturate(filters[2] / 100);\n        color.hueRotate(filters[3] * 3.6);\n        color.brightness(filters[4] / 100);\n        color.contrast(filters[5] / 100);\n        var colorHSL = color.hsl();\n        return (Math.abs(color.r - this.target.r) +\n            Math.abs(color.g - this.target.g) +\n            Math.abs(color.b - this.target.b) +\n            Math.abs(colorHSL.h - this.targetHSL.h) +\n            Math.abs(colorHSL.s - this.targetHSL.s) +\n            Math.abs(colorHSL.l - this.targetHSL.l));\n    };\n    /**\n     * Returns the CSS filter list for the received HEX color\n     *\n     * @private\n     * @param {number[]} filters\n     * @returns {string}\n     * @memberof Solver\n     */\n    Solver.prototype.css = function (filters) {\n        var formatCssFilterValueByMultiplier = function (idx, multiplier) {\n            if (multiplier === void 0) { multiplier = 1; }\n            return Math.round(filters[idx] * multiplier);\n        };\n        return [\n            \"invert(\".concat(formatCssFilterValueByMultiplier(0), \"%)\"),\n            \"sepia(\".concat(formatCssFilterValueByMultiplier(1), \"%)\"),\n            \"saturate(\".concat(formatCssFilterValueByMultiplier(2), \"%)\"),\n            \"hue-rotate(\".concat(formatCssFilterValueByMultiplier(3, 3.6), \"deg)\"),\n            \"brightness(\".concat(formatCssFilterValueByMultiplier(4), \"%)\"),\n            \"contrast(\".concat(formatCssFilterValueByMultiplier(5), \"%)\"),\n        ].join(' ');\n    };\n    return Solver;\n}());\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGV4LXRvLWNzcy1maWx0ZXIvZGlzdC9lc20vc29sdmVyLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5Q0FBSztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixpQkFBaUIsaUJBQWlCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixVQUFVLGlCQUFpQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxhQUFhO0FBQzVCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLHNCQUFzQjtBQUNoRDtBQUNBLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsdUJBQXVCO0FBQ3RDLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ2lCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc2NpZW5jZXdvcmxkLWFyLXJlYWN0Ly4vbm9kZV9tb2R1bGVzL2hleC10by1jc3MtZmlsdGVyL2Rpc3QvZXNtL3NvbHZlci5qcz9hZWQ3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbG9yIH0gZnJvbSAnLi9jb2xvcic7XG52YXIgU29sdmVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFNvbHZlcih0YXJnZXQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMudGFyZ2V0SFNMID0gdGFyZ2V0LmhzbCgpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBcbiAgICAgICAgLy8gQWRkaW5nIGRlZmF1bHQgdmFsdWVzIGZvciBvcHRpb25zXG4gICAgICAgIHtcbiAgICAgICAgICAgIGFjY2VwdGFuY2VMb3NzUGVyY2VudGFnZTogNSxcbiAgICAgICAgICAgIG1heENoZWNrczogMTUsXG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgICAgICAvLyBBbGwgdGhlIGNhbGNzIGRvbmUgYnkgdGhlIGxpYnJhcnkgdG8gZ2VuZXJhdGVcbiAgICAgICAgLy8gYSBDU1MgRmlsdGVyIGFyZSBiYXNlZCBvbiB0aGUgY29sb3IgYCMwMDBgXG4gICAgICAgIC8vIGluIHRoaXMgY2FzZSwgYHJnYigwLCAwLCAwKWBcbiAgICAgICAgLy8gUGxlYXNlIG1ha2Ugc3VyZSB0aGUgYmFja2dyb3VuZCBvZiB0aGUgZWxlbWVudFxuICAgICAgICAvLyBpcyBgIzAwMGAgZm9yIGJldHRlciBwZXJmb3JtYW5jZVxuICAgICAgICAvLyBhbmQgY29sb3Igc2ltaWxhcml0eS5cbiAgICAgICAgdGhpcy5yZXVzZWRDb2xvciA9IG5ldyBDb2xvcigwLCAwLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgc29sdmVkIHZhbHVlcyBmb3IgdGhlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7KFNQU0FQYXlsb2FkICYgeyBmaWx0ZXI6IHN0cmluZzsgfSl9XG4gICAgICogQG1lbWJlcm9mIFNvbHZlclxuICAgICAqL1xuICAgIFNvbHZlci5wcm90b3R5cGUuc29sdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSB0aGlzLnNvbHZlTmFycm93KHRoaXMuc29sdmVXaWRlKCkpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdmFsdWVzOiByZXN1bHQudmFsdWVzLFxuICAgICAgICAgICAgY2FsbGVkOiByZXN1bHQuY2FsbGVkLFxuICAgICAgICAgICAgbG9zczogcmVzdWx0Lmxvc3MsXG4gICAgICAgICAgICBmaWx0ZXI6IHRoaXMuY3NzKHJlc3VsdC52YWx1ZXMpLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgLyoqXG4gICAgICogU29sdmUgd2lkZSB2YWx1ZXMgYmFzZWQgb24gdGhlIHdpZGUgdmFsdWVzIGZvciBSR0IgYW5kIEhTTCB2YWx1ZXNcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge1NQU0FQYXlsb2FkfVxuICAgICAqIEBtZW1iZXJvZiBTb2x2ZXJcbiAgICAgKi9cbiAgICBTb2x2ZXIucHJvdG90eXBlLnNvbHZlV2lkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIEEgPSA1O1xuICAgICAgICB2YXIgYyA9IDE1O1xuICAgICAgICAvLyBXaWRlIHZhbHVlcyBmb3IgUkdCIGFuZCBIU0wgdmFsdWVzXG4gICAgICAgIC8vIHRoZSB2YWx1ZXMgaW4gdGhlIG9yZGVyOiBbYHJgLCBgZ2AsIGBiYCwgYGhgLCBgc2AsIGBsYF1cbiAgICAgICAgdmFyIGEgPSBbNjAsIDE4MCwgMTgwMDAsIDYwMCwgMS4yLCAxLjJdO1xuICAgICAgICB2YXIgYmVzdCA9IHsgbG9zczogSW5maW5pdHkgfTtcbiAgICAgICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgICAgICB3aGlsZSAoYmVzdC5sb3NzID4gdGhpcy5vcHRpb25zLmFjY2VwdGFuY2VMb3NzUGVyY2VudGFnZSkge1xuICAgICAgICAgICAgdmFyIGluaXRpYWxGaWx0ZXJWYWx1ZXMgPSBbNTAsIDIwLCAzNzUwLCA1MCwgMTAwLCAxMDBdO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuc3BzYSh7XG4gICAgICAgICAgICAgICAgQTogQSxcbiAgICAgICAgICAgICAgICBhOiBhLFxuICAgICAgICAgICAgICAgIGM6IGMsXG4gICAgICAgICAgICAgICAgdmFsdWVzOiBpbml0aWFsRmlsdGVyVmFsdWVzLFxuICAgICAgICAgICAgICAgIC8vIGZvciB3aWRlIHZhbHVlcyB3ZSBzaG91bGQgdXNlIHRoZSBkb3VibGUgb2YgdHJpZXMgaW5cbiAgICAgICAgICAgICAgICAvLyBjb21wYXJpc29uIG9mIGBzb2x2ZU5hcnJvdygpYCBtZXRob2RcbiAgICAgICAgICAgICAgICBtYXhUcmllc0luTG9vcDogMTAwMCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5sb3NzIDwgYmVzdC5sb3NzKSB7XG4gICAgICAgICAgICAgICAgYmVzdCA9IHJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvdW50ZXIgKz0gMTtcbiAgICAgICAgICAgIGlmIChjb3VudGVyID49IHRoaXMub3B0aW9ucy5tYXhDaGVja3MpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgYmVzdCwgeyBjYWxsZWQ6IGNvdW50ZXIgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBTb2x2ZSBuYXJyb3cgdmFsdWVzIGJhc2VkIG9uIHRoZSB3aWRlIHZhbHVlcyBmb3IgdGhlIGZpbHRlclxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge1NQU0FQYXlsb2FkfSB3aWRlXG4gICAgICogQHJldHVybnMge1NQU0FQYXlsb2FkfVxuICAgICAqIEBtZW1iZXJvZiBTb2x2ZXJcbiAgICAgKi9cbiAgICBTb2x2ZXIucHJvdG90eXBlLnNvbHZlTmFycm93ID0gZnVuY3Rpb24gKHdpZGUpIHtcbiAgICAgICAgdmFyIEEgPSB3aWRlLmxvc3M7XG4gICAgICAgIHZhciBjID0gMjtcbiAgICAgICAgdmFyIEExID0gQSArIDE7XG4gICAgICAgIC8vIE5hcnJvdyB2YWx1ZXMgZm9yIFJHQiBhbmQgSFNMIHZhbHVlc1xuICAgICAgICAvLyB0aGUgdmFsdWVzIGluIHRoZSBvcmRlcjogW2ByYCwgYGdgLCBgYmAsIGBoYCwgYHNgLCBgbGBdXG4gICAgICAgIHZhciBhID0gWzAuMjUgKiBBMSwgMC4yNSAqIEExLCBBMSwgMC4yNSAqIEExLCAwLjIgKiBBMSwgMC4yICogQTFdO1xuICAgICAgICByZXR1cm4gdGhpcy5zcHNhKHtcbiAgICAgICAgICAgIEE6IEEsXG4gICAgICAgICAgICBhOiBhLFxuICAgICAgICAgICAgYzogYyxcbiAgICAgICAgICAgIHZhbHVlczogd2lkZS52YWx1ZXMsXG4gICAgICAgICAgICBtYXhUcmllc0luTG9vcDogNTAwLFxuICAgICAgICAgICAgY2FsbGVkOiB3aWRlLmNhbGxlZCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGZpbmFsIHZhbHVlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGZpbHRlciBvcmRlclxuICAgICAqIHRvIGdldCB0aGUgb3JkZXIsIHBsZWFzZSBjaGVjayB0aGUgcmV0dXJuZWQgdmFsdWVcbiAgICAgKiBpbiBgY3NzKClgIG1ldGhvZFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaWR4XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgU29sdmVyXG4gICAgICovXG4gICAgU29sdmVyLnByb3RvdHlwZS5maXhWYWx1ZUJ5RmlsdGVySURYID0gZnVuY3Rpb24gKHZhbHVlLCBpZHgpIHtcbiAgICAgICAgdmFyIG1heCA9IDEwMDtcbiAgICAgICAgLy8gRml4aW5nIG1heCwgbWluaW11bSBhbmQgdmFsdWUgYnkgZmlsdGVyXG4gICAgICAgIGlmIChpZHggPT09IDIgLyogc2F0dXJhdGUgKi8pIHtcbiAgICAgICAgICAgIG1heCA9IDc1MDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaWR4ID09PSA0IC8qIGJyaWdodG5lc3MgKi8gfHwgaWR4ID09PSA1IC8qIGNvbnRyYXN0ICovKSB7XG4gICAgICAgICAgICBtYXggPSAyMDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlkeCA9PT0gMyAvKiBodWUtcm90YXRlICovKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSAlPSBtYXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IG1heCArICh2YWx1ZSAlIG1heCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2tpbmcgaWYgdmFsdWUgaXMgYmVsb3cgdGhlIG1pbmltdW0gb3IgYWJvdmVcbiAgICAgICAgLy8gdGhlIG1heGltdW0gYWxsb3dlZCBieSBmaWx0ZXJcbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPCAwKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUgPiBtYXgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gbWF4O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICAgIFNvbHZlci5wcm90b3R5cGUuc3BzYSA9IGZ1bmN0aW9uIChfYSkge1xuICAgICAgICB2YXIgQSA9IF9hLkEsIGEgPSBfYS5hLCBjID0gX2EuYywgdmFsdWVzID0gX2EudmFsdWVzLCBfYiA9IF9hLm1heFRyaWVzSW5Mb29wLCBtYXhUcmllc0luTG9vcCA9IF9iID09PSB2b2lkIDAgPyA1MDAgOiBfYiwgX2MgPSBfYS5jYWxsZWQsIGNhbGxlZCA9IF9jID09PSB2b2lkIDAgPyAwIDogX2M7XG4gICAgICAgIHZhciBhbHBoYSA9IDE7XG4gICAgICAgIHZhciBnYW1tYSA9IDAuMTY2NjY2NjY2NjY2NjY2NjY7XG4gICAgICAgIHZhciBiZXN0ID0gbnVsbDtcbiAgICAgICAgdmFyIGJlc3RMb3NzID0gSW5maW5pdHk7XG4gICAgICAgIHZhciBkZWx0YXMgPSBuZXcgQXJyYXkoNik7XG4gICAgICAgIHZhciBoaWdoQXJncyA9IG5ldyBBcnJheSg2KTtcbiAgICAgICAgdmFyIGxvd0FyZ3MgPSBuZXcgQXJyYXkoNik7XG4gICAgICAgIC8vIFNpemUgb2YgYWxsIENTUyBmaWx0ZXJzIHRvIGJlIGFwcGxpZWQgdG8gZ2V0IHRoZSBjb3JyZWN0IGNvbG9yXG4gICAgICAgIHZhciBmaWx0ZXJzVG9CZUFwcGxpZWRTaXplID0gNjtcbiAgICAgICAgZm9yICh2YXIga2V5ID0gMDsga2V5IDwgbWF4VHJpZXNJbkxvb3A7IGtleSsrKSB7XG4gICAgICAgICAgICB2YXIgY2sgPSBjIC8gTWF0aC5wb3coa2V5ICsgMSwgZ2FtbWEpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWx0ZXJzVG9CZUFwcGxpZWRTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICBkZWx0YXNbaV0gPSBNYXRoLnJhbmRvbSgpID4gMC41ID8gMSA6IC0xO1xuICAgICAgICAgICAgICAgIGhpZ2hBcmdzW2ldID0gdmFsdWVzW2ldICsgY2sgKiBkZWx0YXNbaV07XG4gICAgICAgICAgICAgICAgbG93QXJnc1tpXSA9IHZhbHVlc1tpXSAtIGNrICogZGVsdGFzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxvc3NEaWZmID0gdGhpcy5sb3NzKGhpZ2hBcmdzKSAtIHRoaXMubG9zcyhsb3dBcmdzKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmlsdGVyc1RvQmVBcHBsaWVkU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGcgPSAobG9zc0RpZmYgLyAoMiAqIGNrKSkgKiBkZWx0YXNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGFrID0gYVtpXSAvIE1hdGgucG93KEEgKyBrZXkgKyAxLCBhbHBoYSk7XG4gICAgICAgICAgICAgICAgdmFsdWVzW2ldID0gdGhpcy5maXhWYWx1ZUJ5RmlsdGVySURYKHZhbHVlc1tpXSAtIGFrICogZywgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbG9zcyA9IHRoaXMubG9zcyh2YWx1ZXMpO1xuICAgICAgICAgICAgaWYgKGxvc3MgPCBiZXN0TG9zcykge1xuICAgICAgICAgICAgICAgIGJlc3QgPSB2YWx1ZXMuc2xpY2UoMCk7XG4gICAgICAgICAgICAgICAgYmVzdExvc3MgPSBsb3NzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHZhbHVlczogYmVzdCwgbG9zczogYmVzdExvc3MsIGNhbGxlZDogY2FsbGVkIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDaGVja3MgaG93IG11Y2ggaXMgdGhlIGxvc3MgZm9yIHRoZSBmaWx0ZXIgaW4gUkdCIGFuZCBIU0wgY29sb3JzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7U1BTQVBheWxvYWRbJ3ZhbHVlcyddfSBmaWx0ZXJzXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAbWVtYmVyb2YgU29sdmVyXG4gICAgICovXG4gICAgU29sdmVyLnByb3RvdHlwZS5sb3NzID0gZnVuY3Rpb24gKGZpbHRlcnMpIHtcbiAgICAgICAgLy8gQXJndW1lbnQgYXMgYW4gQXJyYXkgb2YgcGVyY2VudGFnZXMuXG4gICAgICAgIHZhciBjb2xvciA9IHRoaXMucmV1c2VkQ29sb3I7XG4gICAgICAgIC8vIFJlc2V0dGluZyB0aGUgY29sb3IgdG8gYmxhY2sgaW4gY2FzZVxuICAgICAgICAvLyBpdCB3YXMgY2FsbGVkIG1vcmUgdGhhbiBvbmNlXG4gICAgICAgIGNvbG9yLnNldCgwLCAwLCAwKTtcbiAgICAgICAgY29sb3IuaW52ZXJ0KGZpbHRlcnNbMF0gLyAxMDApO1xuICAgICAgICBjb2xvci5zZXBpYShmaWx0ZXJzWzFdIC8gMTAwKTtcbiAgICAgICAgY29sb3Iuc2F0dXJhdGUoZmlsdGVyc1syXSAvIDEwMCk7XG4gICAgICAgIGNvbG9yLmh1ZVJvdGF0ZShmaWx0ZXJzWzNdICogMy42KTtcbiAgICAgICAgY29sb3IuYnJpZ2h0bmVzcyhmaWx0ZXJzWzRdIC8gMTAwKTtcbiAgICAgICAgY29sb3IuY29udHJhc3QoZmlsdGVyc1s1XSAvIDEwMCk7XG4gICAgICAgIHZhciBjb2xvckhTTCA9IGNvbG9yLmhzbCgpO1xuICAgICAgICByZXR1cm4gKE1hdGguYWJzKGNvbG9yLnIgLSB0aGlzLnRhcmdldC5yKSArXG4gICAgICAgICAgICBNYXRoLmFicyhjb2xvci5nIC0gdGhpcy50YXJnZXQuZykgK1xuICAgICAgICAgICAgTWF0aC5hYnMoY29sb3IuYiAtIHRoaXMudGFyZ2V0LmIpICtcbiAgICAgICAgICAgIE1hdGguYWJzKGNvbG9ySFNMLmggLSB0aGlzLnRhcmdldEhTTC5oKSArXG4gICAgICAgICAgICBNYXRoLmFicyhjb2xvckhTTC5zIC0gdGhpcy50YXJnZXRIU0wucykgK1xuICAgICAgICAgICAgTWF0aC5hYnMoY29sb3JIU0wubCAtIHRoaXMudGFyZ2V0SFNMLmwpKTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIENTUyBmaWx0ZXIgbGlzdCBmb3IgdGhlIHJlY2VpdmVkIEhFWCBjb2xvclxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBmaWx0ZXJzXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyb2YgU29sdmVyXG4gICAgICovXG4gICAgU29sdmVyLnByb3RvdHlwZS5jc3MgPSBmdW5jdGlvbiAoZmlsdGVycykge1xuICAgICAgICB2YXIgZm9ybWF0Q3NzRmlsdGVyVmFsdWVCeU11bHRpcGxpZXIgPSBmdW5jdGlvbiAoaWR4LCBtdWx0aXBsaWVyKSB7XG4gICAgICAgICAgICBpZiAobXVsdGlwbGllciA9PT0gdm9pZCAwKSB7IG11bHRpcGxpZXIgPSAxOyB9XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChmaWx0ZXJzW2lkeF0gKiBtdWx0aXBsaWVyKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIFwiaW52ZXJ0KFwiLmNvbmNhdChmb3JtYXRDc3NGaWx0ZXJWYWx1ZUJ5TXVsdGlwbGllcigwKSwgXCIlKVwiKSxcbiAgICAgICAgICAgIFwic2VwaWEoXCIuY29uY2F0KGZvcm1hdENzc0ZpbHRlclZhbHVlQnlNdWx0aXBsaWVyKDEpLCBcIiUpXCIpLFxuICAgICAgICAgICAgXCJzYXR1cmF0ZShcIi5jb25jYXQoZm9ybWF0Q3NzRmlsdGVyVmFsdWVCeU11bHRpcGxpZXIoMiksIFwiJSlcIiksXG4gICAgICAgICAgICBcImh1ZS1yb3RhdGUoXCIuY29uY2F0KGZvcm1hdENzc0ZpbHRlclZhbHVlQnlNdWx0aXBsaWVyKDMsIDMuNiksIFwiZGVnKVwiKSxcbiAgICAgICAgICAgIFwiYnJpZ2h0bmVzcyhcIi5jb25jYXQoZm9ybWF0Q3NzRmlsdGVyVmFsdWVCeU11bHRpcGxpZXIoNCksIFwiJSlcIiksXG4gICAgICAgICAgICBcImNvbnRyYXN0KFwiLmNvbmNhdChmb3JtYXRDc3NGaWx0ZXJWYWx1ZUJ5TXVsdGlwbGllcig1KSwgXCIlKVwiKSxcbiAgICAgICAgXS5qb2luKCcgJyk7XG4gICAgfTtcbiAgICByZXR1cm4gU29sdmVyO1xufSgpKTtcbmV4cG9ydCB7IFNvbHZlciB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/hex-to-css-filter/dist/esm/solver.js\n");

/***/ })

};
;