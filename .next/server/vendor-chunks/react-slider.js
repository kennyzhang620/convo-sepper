"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-slider";
exports.ids = ["vendor-chunks/react-slider"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-slider/dist/es/dev/components/ReactSlider/ReactSlider.mjs":
/*!**************************************************************************************!*\
  !*** ./node_modules/react-slider/dist/es/dev/components/ReactSlider/ReactSlider.mjs ***!
  \**************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ReactSlider$1)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/extends.js\");\n/* harmony import */ var _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/inheritsLoose */ \"(ssr)/./node_modules/@babel/runtime/helpers/inheritsLoose.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var prop_types__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! prop-types */ \"(ssr)/./node_modules/prop-types/index.js\");\n\n\n\n\n\nvar _jsxFileName = \"/Users/krise/github/react-slider/src/components/ReactSlider/ReactSlider.jsx\";\n/**\n * To prevent text selection while dragging.\n * http://stackoverflow.com/questions/5429827/how-can-i-prevent-text-element-selection-with-cursor-drag\n */\n\nfunction pauseEvent(e) {\n  if (e && e.stopPropagation) {\n    e.stopPropagation();\n  }\n\n  if (e && e.preventDefault) {\n    e.preventDefault();\n  }\n\n  return false;\n}\n\nfunction stopPropagation(e) {\n  if (e.stopPropagation) {\n    e.stopPropagation();\n  }\n}\n\nfunction sanitizeInValue(x) {\n  if (x == null) {\n    return [];\n  }\n\n  return Array.isArray(x) ? x.slice() : [x];\n}\n\nfunction prepareOutValue(x) {\n  return x !== null && x.length === 1 ? x[0] : x.slice();\n}\n\nfunction trimSucceeding(length, nextValue, minDistance, max) {\n  for (let i = 0; i < length; i += 1) {\n    const padding = max - i * minDistance;\n\n    if (nextValue[length - 1 - i] > padding) {\n      // eslint-disable-next-line no-param-reassign\n      nextValue[length - 1 - i] = padding;\n    }\n  }\n}\n\nfunction trimPreceding(length, nextValue, minDistance, min) {\n  for (let i = 0; i < length; i += 1) {\n    const padding = min + i * minDistance;\n\n    if (nextValue[i] < padding) {\n      // eslint-disable-next-line no-param-reassign\n      nextValue[i] = padding;\n    }\n  }\n}\n\nfunction addHandlers(eventMap) {\n  Object.keys(eventMap).forEach(key => {\n    if (typeof document !== 'undefined') {\n      document.addEventListener(key, eventMap[key], false);\n    }\n  });\n}\n\nfunction removeHandlers(eventMap) {\n  Object.keys(eventMap).forEach(key => {\n    if (typeof document !== 'undefined') {\n      document.removeEventListener(key, eventMap[key], false);\n    }\n  });\n}\n\nfunction trimAlignValue(val, props) {\n  return alignValue(trimValue(val, props), props);\n}\n\nfunction alignValue(val, props) {\n  const valModStep = (val - props.min) % props.step;\n  let alignedValue = val - valModStep;\n\n  if (Math.abs(valModStep) * 2 >= props.step) {\n    alignedValue += valModStep > 0 ? props.step : -props.step;\n  }\n\n  return parseFloat(alignedValue.toFixed(5));\n}\n\nfunction trimValue(val, props) {\n  let trimmed = val;\n\n  if (trimmed <= props.min) {\n    trimmed = props.min;\n  }\n\n  if (trimmed >= props.max) {\n    trimmed = props.max;\n  }\n\n  return trimmed;\n}\n\nlet ReactSlider = /*#__PURE__*/function (_React$Component) {\n  _babel_runtime_helpers_inheritsLoose__WEBPACK_IMPORTED_MODULE_1__(ReactSlider, _React$Component);\n\n  function ReactSlider(_props) {\n    var _this;\n\n    _this = _React$Component.call(this, _props) || this;\n\n    _this.onKeyUp = () => {\n      _this.onEnd();\n    };\n\n    _this.onMouseUp = () => {\n      _this.onEnd(_this.getMouseEventMap());\n    };\n\n    _this.onTouchEnd = e => {\n      e.preventDefault();\n\n      _this.onEnd(_this.getTouchEventMap());\n    };\n\n    _this.onBlur = () => {\n      _this.setState({\n        index: -1\n      }, _this.onEnd(_this.getKeyDownEventMap()));\n    };\n\n    _this.onMouseMove = e => {\n      // Prevent controlled updates from happening while mouse is moving\n      _this.setState({\n        pending: true\n      });\n\n      const position = _this.getMousePosition(e);\n\n      const diffPosition = _this.getDiffPosition(position[0]);\n\n      const newValue = _this.getValueFromPosition(diffPosition);\n\n      _this.move(newValue);\n    };\n\n    _this.onTouchMove = e => {\n      if (e.touches.length > 1) {\n        return;\n      } // Prevent controlled updates from happending while touch is moving\n\n\n      _this.setState({\n        pending: true\n      });\n\n      const position = _this.getTouchPosition(e);\n\n      if (typeof _this.isScrolling === 'undefined') {\n        const diffMainDir = position[0] - _this.startPosition[0];\n        const diffScrollDir = position[1] - _this.startPosition[1];\n        _this.isScrolling = Math.abs(diffScrollDir) > Math.abs(diffMainDir);\n      }\n\n      if (_this.isScrolling) {\n        _this.setState({\n          index: -1\n        });\n\n        return;\n      }\n\n      const diffPosition = _this.getDiffPosition(position[0]);\n\n      const newValue = _this.getValueFromPosition(diffPosition);\n\n      _this.move(newValue);\n    };\n\n    _this.onKeyDown = e => {\n      if (e.ctrlKey || e.shiftKey || e.altKey || e.metaKey) {\n        return;\n      } // Prevent controlled updates from happening while a key is pressed\n\n\n      _this.setState({\n        pending: true\n      });\n\n      switch (e.key) {\n        case 'ArrowLeft':\n        case 'ArrowDown':\n        case 'Left':\n        case 'Down':\n          e.preventDefault();\n\n          _this.moveDownByStep();\n\n          break;\n\n        case 'ArrowRight':\n        case 'ArrowUp':\n        case 'Right':\n        case 'Up':\n          e.preventDefault();\n\n          _this.moveUpByStep();\n\n          break;\n\n        case 'Home':\n          e.preventDefault();\n\n          _this.move(_this.props.min);\n\n          break;\n\n        case 'End':\n          e.preventDefault();\n\n          _this.move(_this.props.max);\n\n          break;\n\n        case 'PageDown':\n          e.preventDefault();\n\n          _this.moveDownByStep(_this.props.pageFn(_this.props.step));\n\n          break;\n\n        case 'PageUp':\n          e.preventDefault();\n\n          _this.moveUpByStep(_this.props.pageFn(_this.props.step));\n\n          break;\n      }\n    };\n\n    _this.onSliderMouseDown = e => {\n      // do nothing if disabled or right click\n      if (_this.props.disabled || e.button === 2) {\n        return;\n      } // Prevent controlled updates from happening while mouse is moving\n\n\n      _this.setState({\n        pending: true\n      });\n\n      if (!_this.props.snapDragDisabled) {\n        const position = _this.getMousePosition(e);\n\n        _this.forceValueFromPosition(position[0], i => {\n          _this.start(i, position[0]);\n\n          addHandlers(_this.getMouseEventMap());\n        });\n      }\n\n      pauseEvent(e);\n    };\n\n    _this.onSliderClick = e => {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      if (_this.props.onSliderClick && !_this.hasMoved) {\n        const position = _this.getMousePosition(e);\n\n        const valueAtPos = trimAlignValue(_this.calcValue(_this.calcOffsetFromPosition(position[0])), _this.props);\n\n        _this.props.onSliderClick(valueAtPos);\n      }\n    };\n\n    _this.createOnKeyDown = i => e => {\n      if (_this.props.disabled) {\n        return;\n      }\n\n      _this.start(i);\n\n      addHandlers(_this.getKeyDownEventMap());\n      pauseEvent(e);\n    };\n\n    _this.createOnMouseDown = i => e => {\n      // do nothing if disabled or right click\n      if (_this.props.disabled || e.button === 2) {\n        return;\n      } // Prevent controlled updates from happending while mouse is moving\n\n\n      _this.setState({\n        pending: true\n      });\n\n      const position = _this.getMousePosition(e);\n\n      _this.start(i, position[0]);\n\n      addHandlers(_this.getMouseEventMap());\n      pauseEvent(e);\n    };\n\n    _this.createOnTouchStart = i => e => {\n      if (_this.props.disabled || e.touches.length > 1) {\n        return;\n      } // Prevent controlled updates from happending while touch is moving\n\n\n      _this.setState({\n        pending: true\n      });\n\n      const position = _this.getTouchPosition(e);\n\n      _this.startPosition = position; // don't know yet if the user is trying to scroll\n\n      _this.isScrolling = undefined;\n\n      _this.start(i, position[0]);\n\n      addHandlers(_this.getTouchEventMap());\n      stopPropagation(e);\n    };\n\n    _this.handleResize = () => {\n      // setTimeout of 0 gives element enough time to have assumed its new size if\n      // it is being resized\n      const resizeTimeout = window.setTimeout(() => {\n        // drop this timeout from pendingResizeTimeouts to reduce memory usage\n        _this.pendingResizeTimeouts.shift();\n\n        _this.resize();\n      }, 0);\n\n      _this.pendingResizeTimeouts.push(resizeTimeout);\n    };\n\n    _this.renderThumb = (style, i) => {\n      const className = _this.props.thumbClassName + \" \" + _this.props.thumbClassName + \"-\" + i + \" \" + (_this.state.index === i ? _this.props.thumbActiveClassName : '');\n      const props = {\n        'ref': r => {\n          _this[\"thumb\" + i] = r;\n        },\n        'key': _this.props.thumbClassName + \"-\" + i,\n        className,\n        style,\n        'onMouseDown': _this.createOnMouseDown(i),\n        'onTouchStart': _this.createOnTouchStart(i),\n        'onFocus': _this.createOnKeyDown(i),\n        'tabIndex': 0,\n        'role': 'slider',\n        'aria-orientation': _this.props.orientation,\n        'aria-valuenow': _this.state.value[i],\n        'aria-valuemin': _this.props.min,\n        'aria-valuemax': _this.props.max,\n        'aria-label': Array.isArray(_this.props.ariaLabel) ? _this.props.ariaLabel[i] : _this.props.ariaLabel,\n        'aria-labelledby': Array.isArray(_this.props.ariaLabelledby) ? _this.props.ariaLabelledby[i] : _this.props.ariaLabelledby,\n        'aria-disabled': _this.props.disabled\n      };\n      const state = {\n        index: i,\n        value: prepareOutValue(_this.state.value),\n        valueNow: _this.state.value[i]\n      };\n\n      if (_this.props.ariaValuetext) {\n        props['aria-valuetext'] = typeof _this.props.ariaValuetext === 'string' ? _this.props.ariaValuetext : _this.props.ariaValuetext(state);\n      }\n\n      return _this.props.renderThumb(props, state);\n    };\n\n    _this.renderTrack = (i, offsetFrom, offsetTo) => {\n      const props = {\n        key: _this.props.trackClassName + \"-\" + i,\n        className: _this.props.trackClassName + \" \" + _this.props.trackClassName + \"-\" + i,\n        style: _this.buildTrackStyle(offsetFrom, _this.state.upperBound - offsetTo)\n      };\n      const state = {\n        index: i,\n        value: prepareOutValue(_this.state.value)\n      };\n      return _this.props.renderTrack(props, state);\n    };\n\n    let value = sanitizeInValue(_props.value);\n\n    if (!value.length) {\n      value = sanitizeInValue(_props.defaultValue);\n    } // array for storing resize timeouts ids\n\n\n    _this.pendingResizeTimeouts = [];\n    const zIndices = [];\n\n    for (let i = 0; i < value.length; i += 1) {\n      value[i] = trimAlignValue(value[i], _props);\n      zIndices.push(i);\n    }\n\n    _this.resizeObserver = null;\n    _this.resizeElementRef = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__.createRef();\n    _this.state = {\n      index: -1,\n      upperBound: 0,\n      sliderLength: 0,\n      value,\n      zIndices\n    };\n    return _this;\n  }\n\n  var _proto = ReactSlider.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    if (typeof window !== 'undefined') {\n      this.resizeObserver = new ResizeObserver(this.handleResize);\n      this.resizeObserver.observe(this.resizeElementRef.current);\n      this.resize();\n    }\n  } // Keep the internal `value` consistent with an outside `value` if present.\n  // This basically allows the slider to be a controlled component.\n  ;\n\n  ReactSlider.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {\n    const value = sanitizeInValue(props.value);\n\n    if (!value.length) {\n      return null;\n    } // Do not allow controlled upates to happen while we have pending updates\n\n\n    if (state.pending) {\n      return null;\n    }\n\n    return {\n      value: value.map(item => trimAlignValue(item, props))\n    };\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate() {\n    // If an upperBound has not yet been determined (due to the component being hidden\n    // during the mount event, or during the last resize), then calculate it now\n    if (this.state.upperBound === 0) {\n      this.resize();\n    }\n  };\n\n  _proto.componentWillUnmount = function componentWillUnmount() {\n    this.clearPendingResizeTimeouts();\n\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n  };\n\n  _proto.onEnd = function onEnd(eventMap) {\n    if (eventMap) {\n      removeHandlers(eventMap);\n    }\n\n    if (this.hasMoved) {\n      this.fireChangeEvent('onAfterChange');\n    } // Allow controlled updates to continue\n\n\n    this.setState({\n      pending: false\n    });\n    this.hasMoved = false;\n  };\n\n  _proto.getValue = function getValue() {\n    return prepareOutValue(this.state.value);\n  };\n\n  _proto.getClosestIndex = function getClosestIndex(pixelOffset) {\n    let minDist = Number.MAX_VALUE;\n    let closestIndex = -1;\n    const {\n      value\n    } = this.state;\n    const l = value.length;\n\n    for (let i = 0; i < l; i += 1) {\n      const offset = this.calcOffset(value[i]);\n      const dist = Math.abs(pixelOffset - offset);\n\n      if (dist < minDist) {\n        minDist = dist;\n        closestIndex = i;\n      }\n    }\n\n    return closestIndex;\n  };\n\n  _proto.getMousePosition = function getMousePosition(e) {\n    return [e[\"page\" + this.axisKey()], e[\"page\" + this.orthogonalAxisKey()]];\n  };\n\n  _proto.getTouchPosition = function getTouchPosition(e) {\n    const touch = e.touches[0];\n    return [touch[\"page\" + this.axisKey()], touch[\"page\" + this.orthogonalAxisKey()]];\n  };\n\n  _proto.getKeyDownEventMap = function getKeyDownEventMap() {\n    return {\n      keydown: this.onKeyDown,\n      keyup: this.onKeyUp,\n      focusout: this.onBlur\n    };\n  };\n\n  _proto.getMouseEventMap = function getMouseEventMap() {\n    return {\n      mousemove: this.onMouseMove,\n      mouseup: this.onMouseUp\n    };\n  };\n\n  _proto.getTouchEventMap = function getTouchEventMap() {\n    return {\n      touchmove: this.onTouchMove,\n      touchend: this.onTouchEnd\n    };\n  };\n\n  _proto.getValueFromPosition = function getValueFromPosition(position) {\n    const diffValue = position / (this.state.sliderLength - this.state.thumbSize) * (this.props.max - this.props.min);\n    return trimAlignValue(this.state.startValue + diffValue, this.props);\n  };\n\n  _proto.getDiffPosition = function getDiffPosition(position) {\n    let diffPosition = position - this.state.startPosition;\n\n    if (this.props.invert) {\n      diffPosition *= -1;\n    }\n\n    return diffPosition;\n  } // create the `keydown` handler for the i-th thumb\n  ;\n\n  _proto.resize = function resize() {\n    const {\n      slider,\n      thumb0: thumb\n    } = this;\n\n    if (!slider || !thumb) {\n      return;\n    }\n\n    const sizeKey = this.sizeKey(); // For the slider size, we want to use the client width/height, excluding any borders\n\n    const sliderRect = slider.getBoundingClientRect();\n    const sliderSize = slider[sizeKey];\n    const sliderMax = sliderRect[this.posMaxKey()];\n    const sliderMin = sliderRect[this.posMinKey()]; // For the thumb size, we want to use the outer width/height, including any borders\n\n    const thumbRect = thumb.getBoundingClientRect();\n    const thumbSize = thumbRect[sizeKey.replace('client', '').toLowerCase()];\n    const upperBound = sliderSize - thumbSize;\n    const sliderLength = Math.abs(sliderMax - sliderMin);\n\n    if (this.state.upperBound !== upperBound || this.state.sliderLength !== sliderLength || this.state.thumbSize !== thumbSize) {\n      this.setState({\n        upperBound,\n        sliderLength,\n        thumbSize\n      });\n    }\n  } // calculates the offset of a thumb in pixels based on its value.\n  ;\n\n  _proto.calcOffset = function calcOffset(value) {\n    const range = this.props.max - this.props.min;\n\n    if (range === 0) {\n      return 0;\n    }\n\n    const ratio = (value - this.props.min) / range;\n    return ratio * this.state.upperBound;\n  } // calculates the value corresponding to a given pixel offset, i.e. the inverse of `calcOffset`.\n  ;\n\n  _proto.calcValue = function calcValue(offset) {\n    const ratio = offset / this.state.upperBound;\n    return ratio * (this.props.max - this.props.min) + this.props.min;\n  };\n\n  _proto.calcOffsetFromPosition = function calcOffsetFromPosition(position) {\n    const {\n      slider\n    } = this;\n    const sliderRect = slider.getBoundingClientRect();\n    const sliderMax = sliderRect[this.posMaxKey()];\n    const sliderMin = sliderRect[this.posMinKey()]; // The `position` value passed in is the mouse position based on the window height.\n    // The slider bounding rect is based on the viewport, so we must add the window scroll\n    // offset to normalize the values.\n\n    const windowOffset = window[\"page\" + this.axisKey() + \"Offset\"];\n    const sliderStart = windowOffset + (this.props.invert ? sliderMax : sliderMin);\n    let pixelOffset = position - sliderStart;\n\n    if (this.props.invert) {\n      pixelOffset = this.state.sliderLength - pixelOffset;\n    }\n\n    pixelOffset -= this.state.thumbSize / 2;\n    return pixelOffset;\n  } // Snaps the nearest thumb to the value corresponding to `position`\n  // and calls `callback` with that thumb's index.\n  ;\n\n  _proto.forceValueFromPosition = function forceValueFromPosition(position, callback) {\n    const pixelOffset = this.calcOffsetFromPosition(position);\n    const closestIndex = this.getClosestIndex(pixelOffset);\n    const nextValue = trimAlignValue(this.calcValue(pixelOffset), this.props); // Clone this.state.value since we'll modify it temporarily\n    // eslint-disable-next-line zillow/react/no-access-state-in-setstate\n\n    const value = this.state.value.slice();\n    value[closestIndex] = nextValue; // Prevents the slider from shrinking below `props.minDistance`\n\n    for (let i = 0; i < value.length - 1; i += 1) {\n      if (value[i + 1] - value[i] < this.props.minDistance) {\n        return;\n      }\n    }\n\n    this.fireChangeEvent('onBeforeChange');\n    this.hasMoved = true;\n    this.setState({\n      value\n    }, () => {\n      callback(closestIndex);\n      this.fireChangeEvent('onChange');\n    });\n  } // clear all pending timeouts to avoid error messages after unmounting\n  ;\n\n  _proto.clearPendingResizeTimeouts = function clearPendingResizeTimeouts() {\n    do {\n      const nextTimeout = this.pendingResizeTimeouts.shift();\n      clearTimeout(nextTimeout);\n    } while (this.pendingResizeTimeouts.length);\n  };\n\n  _proto.start = function start(i, position) {\n    const thumbRef = this[\"thumb\" + i];\n\n    if (thumbRef) {\n      thumbRef.focus();\n    }\n\n    const {\n      zIndices\n    } = this.state; // remove wherever the element is\n\n    zIndices.splice(zIndices.indexOf(i), 1); // add to end\n\n    zIndices.push(i);\n    this.setState(prevState => ({\n      startValue: prevState.value[i],\n      startPosition: position !== undefined ? position : prevState.startPosition,\n      index: i,\n      zIndices\n    }));\n  };\n\n  _proto.moveUpByStep = function moveUpByStep(step) {\n    if (step === void 0) {\n      step = this.props.step;\n    }\n\n    const oldValue = this.state.value[this.state.index]; // if the slider is inverted and horizontal we want to honor the inverted value\n\n    const newValue = this.props.invert && this.props.orientation === 'horizontal' ? oldValue - step : oldValue + step;\n    const trimAlign = trimAlignValue(newValue, this.props);\n    this.move(Math.min(trimAlign, this.props.max));\n  };\n\n  _proto.moveDownByStep = function moveDownByStep(step) {\n    if (step === void 0) {\n      step = this.props.step;\n    }\n\n    const oldValue = this.state.value[this.state.index]; // if the slider is inverted and horizontal we want to honor the inverted value\n\n    const newValue = this.props.invert && this.props.orientation === 'horizontal' ? oldValue + step : oldValue - step;\n    const trimAlign = trimAlignValue(newValue, this.props);\n    this.move(Math.max(trimAlign, this.props.min));\n  };\n\n  _proto.move = function move(newValue) {\n    // Clone this.state.value since we'll modify it temporarily\n    // eslint-disable-next-line zillow/react/no-access-state-in-setstate\n    const value = this.state.value.slice();\n    const {\n      index\n    } = this.state;\n    const {\n      length\n    } = value; // Short circuit if the value is not changing\n\n    const oldValue = value[index];\n\n    if (newValue === oldValue) {\n      return;\n    } // Trigger only before the first movement\n\n\n    if (!this.hasMoved) {\n      this.fireChangeEvent('onBeforeChange');\n    }\n\n    this.hasMoved = true; // if \"pearling\" (= thumbs pushing each other) is disabled,\n    // prevent the thumb from getting closer than `minDistance` to the previous or next thumb.\n\n    const {\n      pearling,\n      max,\n      min,\n      minDistance\n    } = this.props;\n\n    if (!pearling) {\n      if (index > 0) {\n        const valueBefore = value[index - 1];\n\n        if (newValue < valueBefore + minDistance) {\n          // eslint-disable-next-line no-param-reassign\n          newValue = valueBefore + minDistance;\n        }\n      }\n\n      if (index < length - 1) {\n        const valueAfter = value[index + 1];\n\n        if (newValue > valueAfter - minDistance) {\n          // eslint-disable-next-line no-param-reassign\n          newValue = valueAfter - minDistance;\n        }\n      }\n    }\n\n    value[index] = newValue; // if \"pearling\" is enabled, let the current thumb push the pre- and succeeding thumbs.\n\n    if (pearling && length > 1) {\n      if (newValue > oldValue) {\n        this.pushSucceeding(value, minDistance, index);\n        trimSucceeding(length, value, minDistance, max);\n      } else if (newValue < oldValue) {\n        this.pushPreceding(value, minDistance, index);\n        trimPreceding(length, value, minDistance, min);\n      }\n    } // Normally you would use `shouldComponentUpdate`,\n    // but since the slider is a low-level component,\n    // the extra complexity might be worth the extra performance.\n\n\n    this.setState({\n      value\n    }, this.fireChangeEvent.bind(this, 'onChange'));\n  };\n\n  _proto.pushSucceeding = function pushSucceeding(value, minDistance, index) {\n    let i;\n    let padding;\n\n    for (i = index, padding = value[i] + minDistance; value[i + 1] !== null && padding > value[i + 1]; i += 1, padding = value[i] + minDistance) {\n      // eslint-disable-next-line no-param-reassign\n      value[i + 1] = alignValue(padding, this.props);\n    }\n  };\n\n  _proto.pushPreceding = function pushPreceding(value, minDistance, index) {\n    for (let i = index, padding = value[i] - minDistance; value[i - 1] !== null && padding < value[i - 1]; i -= 1, padding = value[i] - minDistance) {\n      // eslint-disable-next-line no-param-reassign\n      value[i - 1] = alignValue(padding, this.props);\n    }\n  };\n\n  _proto.axisKey = function axisKey() {\n    if (this.props.orientation === 'vertical') {\n      return 'Y';\n    } // Defaults to 'horizontal';\n\n\n    return 'X';\n  };\n\n  _proto.orthogonalAxisKey = function orthogonalAxisKey() {\n    if (this.props.orientation === 'vertical') {\n      return 'X';\n    } // Defaults to 'horizontal'\n\n\n    return 'Y';\n  };\n\n  _proto.posMinKey = function posMinKey() {\n    if (this.props.orientation === 'vertical') {\n      return this.props.invert ? 'bottom' : 'top';\n    } // Defaults to 'horizontal'\n\n\n    return this.props.invert ? 'right' : 'left';\n  };\n\n  _proto.posMaxKey = function posMaxKey() {\n    if (this.props.orientation === 'vertical') {\n      return this.props.invert ? 'top' : 'bottom';\n    } // Defaults to 'horizontal'\n\n\n    return this.props.invert ? 'left' : 'right';\n  };\n\n  _proto.sizeKey = function sizeKey() {\n    if (this.props.orientation === 'vertical') {\n      return 'clientHeight';\n    } // Defaults to 'horizontal'\n\n\n    return 'clientWidth';\n  };\n\n  _proto.fireChangeEvent = function fireChangeEvent(event) {\n    if (this.props[event]) {\n      this.props[event](prepareOutValue(this.state.value), this.state.index);\n    }\n  };\n\n  _proto.buildThumbStyle = function buildThumbStyle(offset, i) {\n    const style = {\n      position: 'absolute',\n      touchAction: 'none',\n      willChange: this.state.index >= 0 ? this.posMinKey() : undefined,\n      zIndex: this.state.zIndices.indexOf(i) + 1\n    };\n    style[this.posMinKey()] = offset + \"px\";\n    return style;\n  };\n\n  _proto.buildTrackStyle = function buildTrackStyle(min, max) {\n    const obj = {\n      position: 'absolute',\n      willChange: this.state.index >= 0 ? this.posMinKey() + \",\" + this.posMaxKey() : undefined\n    };\n    obj[this.posMinKey()] = min;\n    obj[this.posMaxKey()] = max;\n    return obj;\n  };\n\n  _proto.buildMarkStyle = function buildMarkStyle(offset) {\n    var _ref;\n\n    return _ref = {\n      position: 'absolute'\n    }, _ref[this.posMinKey()] = offset, _ref;\n  };\n\n  _proto.renderThumbs = function renderThumbs(offset) {\n    const {\n      length\n    } = offset;\n    const styles = [];\n\n    for (let i = 0; i < length; i += 1) {\n      styles[i] = this.buildThumbStyle(offset[i], i);\n    }\n\n    const res = [];\n\n    for (let i = 0; i < length; i += 1) {\n      res[i] = this.renderThumb(styles[i], i);\n    }\n\n    return res;\n  };\n\n  _proto.renderTracks = function renderTracks(offset) {\n    const tracks = [];\n    const lastIndex = offset.length - 1;\n    tracks.push(this.renderTrack(0, 0, offset[0]));\n\n    for (let i = 0; i < lastIndex; i += 1) {\n      tracks.push(this.renderTrack(i + 1, offset[i], offset[i + 1]));\n    }\n\n    tracks.push(this.renderTrack(lastIndex + 1, offset[lastIndex], this.state.upperBound));\n    return tracks;\n  };\n\n  _proto.renderMarks = function renderMarks() {\n    let {\n      marks\n    } = this.props;\n    const range = this.props.max - this.props.min + 1;\n\n    if (typeof marks === 'boolean') {\n      marks = Array.from({\n        length: range\n      }).map((_, key) => key);\n    } else if (typeof marks === 'number') {\n      marks = Array.from({\n        length: range\n      }).map((_, key) => key).filter(key => key % marks === 0);\n    }\n\n    return marks.map(parseFloat).sort((a, b) => a - b).map(mark => {\n      const offset = this.calcOffset(mark);\n      const props = {\n        key: mark,\n        className: this.props.markClassName,\n        style: this.buildMarkStyle(offset)\n      };\n      return this.props.renderMark(props);\n    });\n  };\n\n  _proto.render = function render() {\n    const offset = [];\n    const {\n      value\n    } = this.state;\n    const l = value.length;\n\n    for (let i = 0; i < l; i += 1) {\n      offset[i] = this.calcOffset(value[i], i);\n    }\n\n    const tracks = this.props.withTracks ? this.renderTracks(offset) : null;\n    const thumbs = this.renderThumbs(offset);\n    const marks = this.props.marks ? this.renderMarks() : null;\n    return /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__.createElement('div', {\n      ref: r => {\n        this.slider = r;\n        this.resizeElementRef.current = r;\n      },\n      style: {\n        position: 'relative'\n      },\n      className: this.props.className + (this.props.disabled ? ' disabled' : ''),\n      onMouseDown: this.onSliderMouseDown,\n      onClick: this.onSliderClick\n    }, tracks, thumbs, marks);\n  };\n\n  return ReactSlider;\n}(react__WEBPACK_IMPORTED_MODULE_2__.Component);\n\nReactSlider.displayName = 'ReactSlider';\nReactSlider.defaultProps = {\n  min: 0,\n  max: 100,\n  step: 1,\n  pageFn: step => step * 10,\n  minDistance: 0,\n  defaultValue: 0,\n  orientation: 'horizontal',\n  className: 'slider',\n  thumbClassName: 'thumb',\n  thumbActiveClassName: 'active',\n  trackClassName: 'track',\n  markClassName: 'mark',\n  withTracks: true,\n  pearling: false,\n  disabled: false,\n  snapDragDisabled: false,\n  invert: false,\n  marks: [],\n  renderThumb: props => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"div\", _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__({}, props, {\n    __self: ReactSlider,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 353,\n      columnNumber: 31\n    }\n  })),\n  renderTrack: props => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"div\", _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__({}, props, {\n    __self: ReactSlider,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 354,\n      columnNumber: 31\n    }\n  })),\n  renderMark: props => /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"span\", _babel_runtime_helpers_extends__WEBPACK_IMPORTED_MODULE_0__({}, props, {\n    __self: ReactSlider,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 355,\n      columnNumber: 30\n    }\n  }))\n};\nReactSlider.propTypes =  true ? {\n  /**\n   * The minimum value of the slider.\n   */\n  min: prop_types__WEBPACK_IMPORTED_MODULE_3__.number,\n\n  /**\n   * The maximum value of the slider.\n   */\n  max: prop_types__WEBPACK_IMPORTED_MODULE_3__.number,\n\n  /**\n   * Value to be added or subtracted on each step the slider makes.\n   * Must be greater than zero.\n   * `max - min` should be evenly divisible by the step value.\n   */\n  step: prop_types__WEBPACK_IMPORTED_MODULE_3__.number,\n\n  /**\n   * The result of the function is the value to be added or subtracted\n   * when the `Page Up` or `Page Down` keys are pressed.\n   *\n   * The current `step` value will be passed as the only argument.\n   * By default, paging will modify `step` by a factor of 10.\n   */\n  pageFn: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,\n\n  /**\n   * The minimal distance between any pair of thumbs.\n   * Must be positive, but zero means they can sit on top of each other.\n   */\n  minDistance: prop_types__WEBPACK_IMPORTED_MODULE_3__.number,\n\n  /**\n   * Determines the initial positions of the thumbs and the number of thumbs.\n   *\n   * If a number is passed a slider with one thumb will be rendered.\n   * If an array is passed each value will determine the position of one thumb.\n   * The values in the array must be sorted.\n   */\n  defaultValue: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3__.number, prop_types__WEBPACK_IMPORTED_MODULE_3__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_3__.number)]),\n\n  /**\n   * Like `defaultValue` but for\n   * [controlled components](http://facebook.github.io/react/docs/forms.html#controlled-components).\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  value: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3__.number, prop_types__WEBPACK_IMPORTED_MODULE_3__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_3__.number)]),\n\n  /**\n   * Determines whether the slider moves horizontally (from left to right)\n   * or vertically (from top to bottom).\n   */\n  orientation: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOf(['horizontal', 'vertical']),\n\n  /**\n   * The css class set on the slider node.\n   */\n  className: prop_types__WEBPACK_IMPORTED_MODULE_3__.string,\n\n  /**\n   * The css class set on each thumb node.\n   *\n   * In addition each thumb will receive a numbered css class of the form\n   * `${thumbClassName}-${i}`, e.g. `thumb-0`, `thumb-1`, ...\n   */\n  thumbClassName: prop_types__WEBPACK_IMPORTED_MODULE_3__.string,\n\n  /**\n   * The css class set on the thumb that is currently being moved.\n   */\n  thumbActiveClassName: prop_types__WEBPACK_IMPORTED_MODULE_3__.string,\n\n  /**\n   * If `true` tracks between the thumbs will be rendered.\n   */\n  withTracks: prop_types__WEBPACK_IMPORTED_MODULE_3__.bool,\n\n  /**\n   * The css class set on the tracks between the thumbs.\n   * In addition track fragment will receive a numbered css class of the form\n   * `${trackClassName}-${i}`, e.g. `track-0`, `track-1`, ...\n   */\n  trackClassName: prop_types__WEBPACK_IMPORTED_MODULE_3__.string,\n\n  /**\n   * If `true` the active thumb will push other thumbs\n   * within the constraints of `min`, `max`, `step` and `minDistance`.\n   */\n  pearling: prop_types__WEBPACK_IMPORTED_MODULE_3__.bool,\n\n  /**\n   * If `true` the thumbs can't be moved.\n   */\n  disabled: prop_types__WEBPACK_IMPORTED_MODULE_3__.bool,\n\n  /**\n   * Disables thumb move when clicking the slider track\n   */\n  snapDragDisabled: prop_types__WEBPACK_IMPORTED_MODULE_3__.bool,\n\n  /**\n   * Inverts the slider.\n   */\n  invert: prop_types__WEBPACK_IMPORTED_MODULE_3__.bool,\n\n  /**\n   * Shows passed marks on the track, if true it shows all the marks,\n   * if an array of numbers it shows just the passed marks, if a number is passed\n   * it shows just the marks in that steps: like passing 3 shows the marks 3, 6, 9\n   */\n  marks: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_3__.number), prop_types__WEBPACK_IMPORTED_MODULE_3__.bool, prop_types__WEBPACK_IMPORTED_MODULE_3__.number]),\n\n  /**\n   * The css class set on the marks.\n   */\n  markClassName: prop_types__WEBPACK_IMPORTED_MODULE_3__.string,\n\n  /**\n   * Callback called before starting to move a thumb. The callback will only be called if the\n   * action will result in a change. The function will be called with two arguments, the first\n   * being the initial value(s) the second being thumb index.\n   */\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n  onBeforeChange: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,\n\n  /**\n   * Callback called on every value change.\n   * The function will be called with two arguments, the first being the new value(s)\n   * the second being thumb index.\n   */\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n  onChange: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,\n\n  /**\n   * Callback called only after moving a thumb has ended. The callback will only be called if\n   * the action resulted in a change. The function will be called with two arguments, the\n   * first being the result value(s) the second being thumb index.\n   */\n  // eslint-disable-next-line max-len\n  // eslint-disable-next-line zillow/react/require-default-props, zillow/react/no-unused-prop-types\n  onAfterChange: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,\n\n  /**\n   * Callback called when the the slider is clicked (thumb or tracks).\n   * Receives the value at the clicked position as argument.\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  onSliderClick: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,\n\n  /**\n   * aria-label for screen-readers to apply to the thumbs.\n   * Use an array for more than one thumb.\n   * The length of the array must match the number of thumbs in the value array.\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  ariaLabel: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3__.string, prop_types__WEBPACK_IMPORTED_MODULE_3__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_3__.string)]),\n\n  /**\n   * aria-labelledby for screen-readers to apply to the thumbs.\n   * Used when slider rendered with separate label.\n   * Use an array for more than one thumb.\n   * The length of the array must match the number of thumbs in the value array.\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  ariaLabelledby: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3__.string, prop_types__WEBPACK_IMPORTED_MODULE_3__.arrayOf(prop_types__WEBPACK_IMPORTED_MODULE_3__.string)]),\n\n  /**\n   * aria-valuetext for screen-readers.\n   * Can be a static string, or a function that returns a string.\n   * The function will be passed a single argument,\n   * an object with the following properties:\n   *\n   *     state => `Value: ${state.value}`\n   *\n   * - `state.index` {`number`} the index of the thumb\n   * - `state.value` {`number` | `array`} the current value state\n   * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  ariaValuetext: prop_types__WEBPACK_IMPORTED_MODULE_3__.oneOfType([prop_types__WEBPACK_IMPORTED_MODULE_3__.string, prop_types__WEBPACK_IMPORTED_MODULE_3__.func]),\n\n  /**\n   * Provide a custom render function for the track node.\n   * The render function will be passed two arguments,\n   * an object with props that should be added to your handle node,\n   * and an object with track and slider state:\n   *\n   *     (props, state) => <div {...props} />\n   *\n   * - `props` {`object`} props to be spread into your track node\n   * - `state.index` {`number`} the index of the track\n   * - `state.value` {`number` | `array`} the current value state\n   */\n  renderTrack: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,\n\n  /**\n   * Provide a custom render function for dynamic thumb content.\n   * The render function will be passed two arguments,\n   * an object with props that should be added to your thumb node,\n   * and an object with thumb and slider state:\n   *\n   *     (props, state) => <div {...props} />\n   *\n   * - `props` {`object`} props to be spread into your thumb node\n   * - `state.index` {`number`} the index of the thumb\n   * - `state.value` {`number` | `array`} the current value state\n   * - `state.valueNow` {`number`} the value of the thumb (i.e. aria-valuenow)\n   */\n  // eslint-disable-next-line zillow/react/require-default-props\n  renderThumb: prop_types__WEBPACK_IMPORTED_MODULE_3__.func,\n\n  /**\n   * Provide a custom render function for the mark node.\n   * The render function will be passed one argument,\n   * an object with props that should be added to your handle node\n   *\n   *     (props) => <span {...props} />\n   *\n   * - `props` {`object`} props to be spread into your track node\n   */\n  renderMark: prop_types__WEBPACK_IMPORTED_MODULE_3__.func\n} : 0;\nvar ReactSlider$1 = ReactSlider;\n\n\n//# sourceMappingURL=ReactSlider.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtc2xpZGVyL2Rpc3QvZXMvZGV2L2NvbXBvbmVudHMvUmVhY3RTbGlkZXIvUmVhY3RTbGlkZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQXNEO0FBQ1k7QUFDeEM7QUFDUzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSxpRUFBYzs7QUFFaEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7O0FBR1I7QUFDQTtBQUNBLE9BQU87O0FBRVA7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSxPQUFPOztBQUVQOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0EsT0FBTzs7QUFFUDs7QUFFQSxzQ0FBc0M7O0FBRXRDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUNBLGtCQUFrQixpREFBbUIsRUFBRSw4Q0FBZ0IsRUFBRSwrQ0FBaUIsQ0FBQyw4Q0FBZ0I7O0FBRTNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEMsc0JBQXNCLG9CQUFvQjtBQUMxQyx5QkFBeUIsVUFBVTtBQUNuQztBQUNBO0FBQ0EsaUJBQWlCLGlEQUFtQixFQUFFLDhDQUFnQixFQUFFLDRDQUFjOztBQUV0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVTtBQUMzQztBQUNBLGdCQUFnQixVQUFVO0FBQzFCLHNCQUFzQixVQUFVO0FBQ2hDLHNCQUFzQixvQkFBb0I7QUFDMUM7QUFDQSxlQUFlLDRDQUFjOztBQUU3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsVUFBVTtBQUMzQztBQUNBLGdCQUFnQixVQUFVO0FBQzFCLHNCQUFzQixVQUFVO0FBQ2hDLHNCQUFzQixvQkFBb0I7QUFDMUMseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBLGVBQWUsNENBQWM7O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsVUFBVTtBQUNyQztBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0EsY0FBYyw0Q0FBYztBQUM1QixFQUFFLEVBQUUsQ0FBRTtBQUNOOztBQUVvQztBQUNwQyIsInNvdXJjZXMiOlsid2VicGFjazovL3NjaWVuY2V3b3JsZC1hci1yZWFjdC8uL25vZGVfbW9kdWxlcy9yZWFjdC1zbGlkZXIvZGlzdC9lcy9kZXYvY29tcG9uZW50cy9SZWFjdFNsaWRlci9SZWFjdFNsaWRlci5tanM/OGI1ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9leHRlbmRzJztcbmltcG9ydCBfaW5oZXJpdHNMb29zZSBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2luaGVyaXRzTG9vc2UnO1xuaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5cbnZhciBfanN4RmlsZU5hbWUgPSBcIi9Vc2Vycy9rcmlzZS9naXRodWIvcmVhY3Qtc2xpZGVyL3NyYy9jb21wb25lbnRzL1JlYWN0U2xpZGVyL1JlYWN0U2xpZGVyLmpzeFwiO1xuLyoqXG4gKiBUbyBwcmV2ZW50IHRleHQgc2VsZWN0aW9uIHdoaWxlIGRyYWdnaW5nLlxuICogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy81NDI5ODI3L2hvdy1jYW4taS1wcmV2ZW50LXRleHQtZWxlbWVudC1zZWxlY3Rpb24td2l0aC1jdXJzb3ItZHJhZ1xuICovXG5cbmZ1bmN0aW9uIHBhdXNlRXZlbnQoZSkge1xuICBpZiAoZSAmJiBlLnN0b3BQcm9wYWdhdGlvbikge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gIH1cblxuICBpZiAoZSAmJiBlLnByZXZlbnREZWZhdWx0KSB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBzdG9wUHJvcGFnYXRpb24oZSkge1xuICBpZiAoZS5zdG9wUHJvcGFnYXRpb24pIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNhbml0aXplSW5WYWx1ZSh4KSB7XG4gIGlmICh4ID09IG51bGwpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICByZXR1cm4gQXJyYXkuaXNBcnJheSh4KSA/IHguc2xpY2UoKSA6IFt4XTtcbn1cblxuZnVuY3Rpb24gcHJlcGFyZU91dFZhbHVlKHgpIHtcbiAgcmV0dXJuIHggIT09IG51bGwgJiYgeC5sZW5ndGggPT09IDEgPyB4WzBdIDogeC5zbGljZSgpO1xufVxuXG5mdW5jdGlvbiB0cmltU3VjY2VlZGluZyhsZW5ndGgsIG5leHRWYWx1ZSwgbWluRGlzdGFuY2UsIG1heCkge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IG1heCAtIGkgKiBtaW5EaXN0YW5jZTtcblxuICAgIGlmIChuZXh0VmFsdWVbbGVuZ3RoIC0gMSAtIGldID4gcGFkZGluZykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICBuZXh0VmFsdWVbbGVuZ3RoIC0gMSAtIGldID0gcGFkZGluZztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJpbVByZWNlZGluZyhsZW5ndGgsIG5leHRWYWx1ZSwgbWluRGlzdGFuY2UsIG1pbikge1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgY29uc3QgcGFkZGluZyA9IG1pbiArIGkgKiBtaW5EaXN0YW5jZTtcblxuICAgIGlmIChuZXh0VmFsdWVbaV0gPCBwYWRkaW5nKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIG5leHRWYWx1ZVtpXSA9IHBhZGRpbmc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZEhhbmRsZXJzKGV2ZW50TWFwKSB7XG4gIE9iamVjdC5rZXlzKGV2ZW50TWFwKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoa2V5LCBldmVudE1hcFtrZXldLCBmYWxzZSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlSGFuZGxlcnMoZXZlbnRNYXApIHtcbiAgT2JqZWN0LmtleXMoZXZlbnRNYXApLmZvckVhY2goa2V5ID0+IHtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihrZXksIGV2ZW50TWFwW2tleV0sIGZhbHNlKTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiB0cmltQWxpZ25WYWx1ZSh2YWwsIHByb3BzKSB7XG4gIHJldHVybiBhbGlnblZhbHVlKHRyaW1WYWx1ZSh2YWwsIHByb3BzKSwgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiBhbGlnblZhbHVlKHZhbCwgcHJvcHMpIHtcbiAgY29uc3QgdmFsTW9kU3RlcCA9ICh2YWwgLSBwcm9wcy5taW4pICUgcHJvcHMuc3RlcDtcbiAgbGV0IGFsaWduZWRWYWx1ZSA9IHZhbCAtIHZhbE1vZFN0ZXA7XG5cbiAgaWYgKE1hdGguYWJzKHZhbE1vZFN0ZXApICogMiA+PSBwcm9wcy5zdGVwKSB7XG4gICAgYWxpZ25lZFZhbHVlICs9IHZhbE1vZFN0ZXAgPiAwID8gcHJvcHMuc3RlcCA6IC1wcm9wcy5zdGVwO1xuICB9XG5cbiAgcmV0dXJuIHBhcnNlRmxvYXQoYWxpZ25lZFZhbHVlLnRvRml4ZWQoNSkpO1xufVxuXG5mdW5jdGlvbiB0cmltVmFsdWUodmFsLCBwcm9wcykge1xuICBsZXQgdHJpbW1lZCA9IHZhbDtcblxuICBpZiAodHJpbW1lZCA8PSBwcm9wcy5taW4pIHtcbiAgICB0cmltbWVkID0gcHJvcHMubWluO1xuICB9XG5cbiAgaWYgKHRyaW1tZWQgPj0gcHJvcHMubWF4KSB7XG4gICAgdHJpbW1lZCA9IHByb3BzLm1heDtcbiAgfVxuXG4gIHJldHVybiB0cmltbWVkO1xufVxuXG5sZXQgUmVhY3RTbGlkZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9SZWFjdCRDb21wb25lbnQpIHtcbiAgX2luaGVyaXRzTG9vc2UoUmVhY3RTbGlkZXIsIF9SZWFjdCRDb21wb25lbnQpO1xuXG4gIGZ1bmN0aW9uIFJlYWN0U2xpZGVyKF9wcm9wcykge1xuICAgIHZhciBfdGhpcztcblxuICAgIF90aGlzID0gX1JlYWN0JENvbXBvbmVudC5jYWxsKHRoaXMsIF9wcm9wcykgfHwgdGhpcztcblxuICAgIF90aGlzLm9uS2V5VXAgPSAoKSA9PiB7XG4gICAgICBfdGhpcy5vbkVuZCgpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbk1vdXNlVXAgPSAoKSA9PiB7XG4gICAgICBfdGhpcy5vbkVuZChfdGhpcy5nZXRNb3VzZUV2ZW50TWFwKCkpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vblRvdWNoRW5kID0gZSA9PiB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgIF90aGlzLm9uRW5kKF90aGlzLmdldFRvdWNoRXZlbnRNYXAoKSk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uQmx1ciA9ICgpID0+IHtcbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgaW5kZXg6IC0xXG4gICAgICB9LCBfdGhpcy5vbkVuZChfdGhpcy5nZXRLZXlEb3duRXZlbnRNYXAoKSkpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbk1vdXNlTW92ZSA9IGUgPT4ge1xuICAgICAgLy8gUHJldmVudCBjb250cm9sbGVkIHVwZGF0ZXMgZnJvbSBoYXBwZW5pbmcgd2hpbGUgbW91c2UgaXMgbW92aW5nXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHBlbmRpbmc6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBwb3NpdGlvbiA9IF90aGlzLmdldE1vdXNlUG9zaXRpb24oZSk7XG5cbiAgICAgIGNvbnN0IGRpZmZQb3NpdGlvbiA9IF90aGlzLmdldERpZmZQb3NpdGlvbihwb3NpdGlvblswXSk7XG5cbiAgICAgIGNvbnN0IG5ld1ZhbHVlID0gX3RoaXMuZ2V0VmFsdWVGcm9tUG9zaXRpb24oZGlmZlBvc2l0aW9uKTtcblxuICAgICAgX3RoaXMubW92ZShuZXdWYWx1ZSk7XG4gICAgfTtcblxuICAgIF90aGlzLm9uVG91Y2hNb3ZlID0gZSA9PiB7XG4gICAgICBpZiAoZS50b3VjaGVzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBQcmV2ZW50IGNvbnRyb2xsZWQgdXBkYXRlcyBmcm9tIGhhcHBlbmRpbmcgd2hpbGUgdG91Y2ggaXMgbW92aW5nXG5cblxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBwZW5kaW5nOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgY29uc3QgcG9zaXRpb24gPSBfdGhpcy5nZXRUb3VjaFBvc2l0aW9uKGUpO1xuXG4gICAgICBpZiAodHlwZW9mIF90aGlzLmlzU2Nyb2xsaW5nID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBkaWZmTWFpbkRpciA9IHBvc2l0aW9uWzBdIC0gX3RoaXMuc3RhcnRQb3NpdGlvblswXTtcbiAgICAgICAgY29uc3QgZGlmZlNjcm9sbERpciA9IHBvc2l0aW9uWzFdIC0gX3RoaXMuc3RhcnRQb3NpdGlvblsxXTtcbiAgICAgICAgX3RoaXMuaXNTY3JvbGxpbmcgPSBNYXRoLmFicyhkaWZmU2Nyb2xsRGlyKSA+IE1hdGguYWJzKGRpZmZNYWluRGlyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLmlzU2Nyb2xsaW5nKSB7XG4gICAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgICBpbmRleDogLTFcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkaWZmUG9zaXRpb24gPSBfdGhpcy5nZXREaWZmUG9zaXRpb24ocG9zaXRpb25bMF0pO1xuXG4gICAgICBjb25zdCBuZXdWYWx1ZSA9IF90aGlzLmdldFZhbHVlRnJvbVBvc2l0aW9uKGRpZmZQb3NpdGlvbik7XG5cbiAgICAgIF90aGlzLm1vdmUobmV3VmFsdWUpO1xuICAgIH07XG5cbiAgICBfdGhpcy5vbktleURvd24gPSBlID0+IHtcbiAgICAgIGlmIChlLmN0cmxLZXkgfHwgZS5zaGlmdEtleSB8fCBlLmFsdEtleSB8fCBlLm1ldGFLZXkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBQcmV2ZW50IGNvbnRyb2xsZWQgdXBkYXRlcyBmcm9tIGhhcHBlbmluZyB3aGlsZSBhIGtleSBpcyBwcmVzc2VkXG5cblxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBwZW5kaW5nOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgc3dpdGNoIChlLmtleSkge1xuICAgICAgICBjYXNlICdBcnJvd0xlZnQnOlxuICAgICAgICBjYXNlICdBcnJvd0Rvd24nOlxuICAgICAgICBjYXNlICdMZWZ0JzpcbiAgICAgICAgY2FzZSAnRG93bic6XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgX3RoaXMubW92ZURvd25CeVN0ZXAoKTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ0Fycm93UmlnaHQnOlxuICAgICAgICBjYXNlICdBcnJvd1VwJzpcbiAgICAgICAgY2FzZSAnUmlnaHQnOlxuICAgICAgICBjYXNlICdVcCc6XG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgICAgX3RoaXMubW92ZVVwQnlTdGVwKCk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdIb21lJzpcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBfdGhpcy5tb3ZlKF90aGlzLnByb3BzLm1pbik7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdFbmQnOlxuICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICAgIF90aGlzLm1vdmUoX3RoaXMucHJvcHMubWF4KTtcblxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgJ1BhZ2VEb3duJzpcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBfdGhpcy5tb3ZlRG93bkJ5U3RlcChfdGhpcy5wcm9wcy5wYWdlRm4oX3RoaXMucHJvcHMuc3RlcCkpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnUGFnZVVwJzpcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICAgICAgICBfdGhpcy5tb3ZlVXBCeVN0ZXAoX3RoaXMucHJvcHMucGFnZUZuKF90aGlzLnByb3BzLnN0ZXApKTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfdGhpcy5vblNsaWRlck1vdXNlRG93biA9IGUgPT4ge1xuICAgICAgLy8gZG8gbm90aGluZyBpZiBkaXNhYmxlZCBvciByaWdodCBjbGlja1xuICAgICAgaWYgKF90aGlzLnByb3BzLmRpc2FibGVkIHx8IGUuYnV0dG9uID09PSAyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gUHJldmVudCBjb250cm9sbGVkIHVwZGF0ZXMgZnJvbSBoYXBwZW5pbmcgd2hpbGUgbW91c2UgaXMgbW92aW5nXG5cblxuICAgICAgX3RoaXMuc2V0U3RhdGUoe1xuICAgICAgICBwZW5kaW5nOiB0cnVlXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFfdGhpcy5wcm9wcy5zbmFwRHJhZ0Rpc2FibGVkKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gX3RoaXMuZ2V0TW91c2VQb3NpdGlvbihlKTtcblxuICAgICAgICBfdGhpcy5mb3JjZVZhbHVlRnJvbVBvc2l0aW9uKHBvc2l0aW9uWzBdLCBpID0+IHtcbiAgICAgICAgICBfdGhpcy5zdGFydChpLCBwb3NpdGlvblswXSk7XG5cbiAgICAgICAgICBhZGRIYW5kbGVycyhfdGhpcy5nZXRNb3VzZUV2ZW50TWFwKCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgcGF1c2VFdmVudChlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMub25TbGlkZXJDbGljayA9IGUgPT4ge1xuICAgICAgaWYgKF90aGlzLnByb3BzLmRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKF90aGlzLnByb3BzLm9uU2xpZGVyQ2xpY2sgJiYgIV90aGlzLmhhc01vdmVkKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gX3RoaXMuZ2V0TW91c2VQb3NpdGlvbihlKTtcblxuICAgICAgICBjb25zdCB2YWx1ZUF0UG9zID0gdHJpbUFsaWduVmFsdWUoX3RoaXMuY2FsY1ZhbHVlKF90aGlzLmNhbGNPZmZzZXRGcm9tUG9zaXRpb24ocG9zaXRpb25bMF0pKSwgX3RoaXMucHJvcHMpO1xuXG4gICAgICAgIF90aGlzLnByb3BzLm9uU2xpZGVyQ2xpY2sodmFsdWVBdFBvcyk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF90aGlzLmNyZWF0ZU9uS2V5RG93biA9IGkgPT4gZSA9PiB7XG4gICAgICBpZiAoX3RoaXMucHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBfdGhpcy5zdGFydChpKTtcblxuICAgICAgYWRkSGFuZGxlcnMoX3RoaXMuZ2V0S2V5RG93bkV2ZW50TWFwKCkpO1xuICAgICAgcGF1c2VFdmVudChlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuY3JlYXRlT25Nb3VzZURvd24gPSBpID0+IGUgPT4ge1xuICAgICAgLy8gZG8gbm90aGluZyBpZiBkaXNhYmxlZCBvciByaWdodCBjbGlja1xuICAgICAgaWYgKF90aGlzLnByb3BzLmRpc2FibGVkIHx8IGUuYnV0dG9uID09PSAyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gUHJldmVudCBjb250cm9sbGVkIHVwZGF0ZXMgZnJvbSBoYXBwZW5kaW5nIHdoaWxlIG1vdXNlIGlzIG1vdmluZ1xuXG5cbiAgICAgIF90aGlzLnNldFN0YXRlKHtcbiAgICAgICAgcGVuZGluZzogdHJ1ZVxuICAgICAgfSk7XG5cbiAgICAgIGNvbnN0IHBvc2l0aW9uID0gX3RoaXMuZ2V0TW91c2VQb3NpdGlvbihlKTtcblxuICAgICAgX3RoaXMuc3RhcnQoaSwgcG9zaXRpb25bMF0pO1xuXG4gICAgICBhZGRIYW5kbGVycyhfdGhpcy5nZXRNb3VzZUV2ZW50TWFwKCkpO1xuICAgICAgcGF1c2VFdmVudChlKTtcbiAgICB9O1xuXG4gICAgX3RoaXMuY3JlYXRlT25Ub3VjaFN0YXJ0ID0gaSA9PiBlID0+IHtcbiAgICAgIGlmIChfdGhpcy5wcm9wcy5kaXNhYmxlZCB8fCBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIFByZXZlbnQgY29udHJvbGxlZCB1cGRhdGVzIGZyb20gaGFwcGVuZGluZyB3aGlsZSB0b3VjaCBpcyBtb3ZpbmdcblxuXG4gICAgICBfdGhpcy5zZXRTdGF0ZSh7XG4gICAgICAgIHBlbmRpbmc6IHRydWVcbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBwb3NpdGlvbiA9IF90aGlzLmdldFRvdWNoUG9zaXRpb24oZSk7XG5cbiAgICAgIF90aGlzLnN0YXJ0UG9zaXRpb24gPSBwb3NpdGlvbjsgLy8gZG9uJ3Qga25vdyB5ZXQgaWYgdGhlIHVzZXIgaXMgdHJ5aW5nIHRvIHNjcm9sbFxuXG4gICAgICBfdGhpcy5pc1Njcm9sbGluZyA9IHVuZGVmaW5lZDtcblxuICAgICAgX3RoaXMuc3RhcnQoaSwgcG9zaXRpb25bMF0pO1xuXG4gICAgICBhZGRIYW5kbGVycyhfdGhpcy5nZXRUb3VjaEV2ZW50TWFwKCkpO1xuICAgICAgc3RvcFByb3BhZ2F0aW9uKGUpO1xuICAgIH07XG5cbiAgICBfdGhpcy5oYW5kbGVSZXNpemUgPSAoKSA9PiB7XG4gICAgICAvLyBzZXRUaW1lb3V0IG9mIDAgZ2l2ZXMgZWxlbWVudCBlbm91Z2ggdGltZSB0byBoYXZlIGFzc3VtZWQgaXRzIG5ldyBzaXplIGlmXG4gICAgICAvLyBpdCBpcyBiZWluZyByZXNpemVkXG4gICAgICBjb25zdCByZXNpemVUaW1lb3V0ID0gd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAvLyBkcm9wIHRoaXMgdGltZW91dCBmcm9tIHBlbmRpbmdSZXNpemVUaW1lb3V0cyB0byByZWR1Y2UgbWVtb3J5IHVzYWdlXG4gICAgICAgIF90aGlzLnBlbmRpbmdSZXNpemVUaW1lb3V0cy5zaGlmdCgpO1xuXG4gICAgICAgIF90aGlzLnJlc2l6ZSgpO1xuICAgICAgfSwgMCk7XG5cbiAgICAgIF90aGlzLnBlbmRpbmdSZXNpemVUaW1lb3V0cy5wdXNoKHJlc2l6ZVRpbWVvdXQpO1xuICAgIH07XG5cbiAgICBfdGhpcy5yZW5kZXJUaHVtYiA9IChzdHlsZSwgaSkgPT4ge1xuICAgICAgY29uc3QgY2xhc3NOYW1lID0gX3RoaXMucHJvcHMudGh1bWJDbGFzc05hbWUgKyBcIiBcIiArIF90aGlzLnByb3BzLnRodW1iQ2xhc3NOYW1lICsgXCItXCIgKyBpICsgXCIgXCIgKyAoX3RoaXMuc3RhdGUuaW5kZXggPT09IGkgPyBfdGhpcy5wcm9wcy50aHVtYkFjdGl2ZUNsYXNzTmFtZSA6ICcnKTtcbiAgICAgIGNvbnN0IHByb3BzID0ge1xuICAgICAgICAncmVmJzogciA9PiB7XG4gICAgICAgICAgX3RoaXNbXCJ0aHVtYlwiICsgaV0gPSByO1xuICAgICAgICB9LFxuICAgICAgICAna2V5JzogX3RoaXMucHJvcHMudGh1bWJDbGFzc05hbWUgKyBcIi1cIiArIGksXG4gICAgICAgIGNsYXNzTmFtZSxcbiAgICAgICAgc3R5bGUsXG4gICAgICAgICdvbk1vdXNlRG93bic6IF90aGlzLmNyZWF0ZU9uTW91c2VEb3duKGkpLFxuICAgICAgICAnb25Ub3VjaFN0YXJ0JzogX3RoaXMuY3JlYXRlT25Ub3VjaFN0YXJ0KGkpLFxuICAgICAgICAnb25Gb2N1cyc6IF90aGlzLmNyZWF0ZU9uS2V5RG93bihpKSxcbiAgICAgICAgJ3RhYkluZGV4JzogMCxcbiAgICAgICAgJ3JvbGUnOiAnc2xpZGVyJyxcbiAgICAgICAgJ2FyaWEtb3JpZW50YXRpb24nOiBfdGhpcy5wcm9wcy5vcmllbnRhdGlvbixcbiAgICAgICAgJ2FyaWEtdmFsdWVub3cnOiBfdGhpcy5zdGF0ZS52YWx1ZVtpXSxcbiAgICAgICAgJ2FyaWEtdmFsdWVtaW4nOiBfdGhpcy5wcm9wcy5taW4sXG4gICAgICAgICdhcmlhLXZhbHVlbWF4JzogX3RoaXMucHJvcHMubWF4LFxuICAgICAgICAnYXJpYS1sYWJlbCc6IEFycmF5LmlzQXJyYXkoX3RoaXMucHJvcHMuYXJpYUxhYmVsKSA/IF90aGlzLnByb3BzLmFyaWFMYWJlbFtpXSA6IF90aGlzLnByb3BzLmFyaWFMYWJlbCxcbiAgICAgICAgJ2FyaWEtbGFiZWxsZWRieSc6IEFycmF5LmlzQXJyYXkoX3RoaXMucHJvcHMuYXJpYUxhYmVsbGVkYnkpID8gX3RoaXMucHJvcHMuYXJpYUxhYmVsbGVkYnlbaV0gOiBfdGhpcy5wcm9wcy5hcmlhTGFiZWxsZWRieSxcbiAgICAgICAgJ2FyaWEtZGlzYWJsZWQnOiBfdGhpcy5wcm9wcy5kaXNhYmxlZFxuICAgICAgfTtcbiAgICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICBpbmRleDogaSxcbiAgICAgICAgdmFsdWU6IHByZXBhcmVPdXRWYWx1ZShfdGhpcy5zdGF0ZS52YWx1ZSksXG4gICAgICAgIHZhbHVlTm93OiBfdGhpcy5zdGF0ZS52YWx1ZVtpXVxuICAgICAgfTtcblxuICAgICAgaWYgKF90aGlzLnByb3BzLmFyaWFWYWx1ZXRleHQpIHtcbiAgICAgICAgcHJvcHNbJ2FyaWEtdmFsdWV0ZXh0J10gPSB0eXBlb2YgX3RoaXMucHJvcHMuYXJpYVZhbHVldGV4dCA9PT0gJ3N0cmluZycgPyBfdGhpcy5wcm9wcy5hcmlhVmFsdWV0ZXh0IDogX3RoaXMucHJvcHMuYXJpYVZhbHVldGV4dChzdGF0ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcy5wcm9wcy5yZW5kZXJUaHVtYihwcm9wcywgc3RhdGUpO1xuICAgIH07XG5cbiAgICBfdGhpcy5yZW5kZXJUcmFjayA9IChpLCBvZmZzZXRGcm9tLCBvZmZzZXRUbykgPT4ge1xuICAgICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgIGtleTogX3RoaXMucHJvcHMudHJhY2tDbGFzc05hbWUgKyBcIi1cIiArIGksXG4gICAgICAgIGNsYXNzTmFtZTogX3RoaXMucHJvcHMudHJhY2tDbGFzc05hbWUgKyBcIiBcIiArIF90aGlzLnByb3BzLnRyYWNrQ2xhc3NOYW1lICsgXCItXCIgKyBpLFxuICAgICAgICBzdHlsZTogX3RoaXMuYnVpbGRUcmFja1N0eWxlKG9mZnNldEZyb20sIF90aGlzLnN0YXRlLnVwcGVyQm91bmQgLSBvZmZzZXRUbylcbiAgICAgIH07XG4gICAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgaW5kZXg6IGksXG4gICAgICAgIHZhbHVlOiBwcmVwYXJlT3V0VmFsdWUoX3RoaXMuc3RhdGUudmFsdWUpXG4gICAgICB9O1xuICAgICAgcmV0dXJuIF90aGlzLnByb3BzLnJlbmRlclRyYWNrKHByb3BzLCBzdGF0ZSk7XG4gICAgfTtcblxuICAgIGxldCB2YWx1ZSA9IHNhbml0aXplSW5WYWx1ZShfcHJvcHMudmFsdWUpO1xuXG4gICAgaWYgKCF2YWx1ZS5sZW5ndGgpIHtcbiAgICAgIHZhbHVlID0gc2FuaXRpemVJblZhbHVlKF9wcm9wcy5kZWZhdWx0VmFsdWUpO1xuICAgIH0gLy8gYXJyYXkgZm9yIHN0b3JpbmcgcmVzaXplIHRpbWVvdXRzIGlkc1xuXG5cbiAgICBfdGhpcy5wZW5kaW5nUmVzaXplVGltZW91dHMgPSBbXTtcbiAgICBjb25zdCB6SW5kaWNlcyA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFsdWVbaV0gPSB0cmltQWxpZ25WYWx1ZSh2YWx1ZVtpXSwgX3Byb3BzKTtcbiAgICAgIHpJbmRpY2VzLnB1c2goaSk7XG4gICAgfVxuXG4gICAgX3RoaXMucmVzaXplT2JzZXJ2ZXIgPSBudWxsO1xuICAgIF90aGlzLnJlc2l6ZUVsZW1lbnRSZWYgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlUmVmKCk7XG4gICAgX3RoaXMuc3RhdGUgPSB7XG4gICAgICBpbmRleDogLTEsXG4gICAgICB1cHBlckJvdW5kOiAwLFxuICAgICAgc2xpZGVyTGVuZ3RoOiAwLFxuICAgICAgdmFsdWUsXG4gICAgICB6SW5kaWNlc1xuICAgIH07XG4gICAgcmV0dXJuIF90aGlzO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFJlYWN0U2xpZGVyLnByb3RvdHlwZTtcblxuICBfcHJvdG8uY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRoaXMucmVzaXplT2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIodGhpcy5oYW5kbGVSZXNpemUpO1xuICAgICAgdGhpcy5yZXNpemVPYnNlcnZlci5vYnNlcnZlKHRoaXMucmVzaXplRWxlbWVudFJlZi5jdXJyZW50KTtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgfVxuICB9IC8vIEtlZXAgdGhlIGludGVybmFsIGB2YWx1ZWAgY29uc2lzdGVudCB3aXRoIGFuIG91dHNpZGUgYHZhbHVlYCBpZiBwcmVzZW50LlxuICAvLyBUaGlzIGJhc2ljYWxseSBhbGxvd3MgdGhlIHNsaWRlciB0byBiZSBhIGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICA7XG5cbiAgUmVhY3RTbGlkZXIuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gZnVuY3Rpb24gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKHByb3BzLCBzdGF0ZSkge1xuICAgIGNvbnN0IHZhbHVlID0gc2FuaXRpemVJblZhbHVlKHByb3BzLnZhbHVlKTtcblxuICAgIGlmICghdmFsdWUubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIERvIG5vdCBhbGxvdyBjb250cm9sbGVkIHVwYXRlcyB0byBoYXBwZW4gd2hpbGUgd2UgaGF2ZSBwZW5kaW5nIHVwZGF0ZXNcblxuXG4gICAgaWYgKHN0YXRlLnBlbmRpbmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogdmFsdWUubWFwKGl0ZW0gPT4gdHJpbUFsaWduVmFsdWUoaXRlbSwgcHJvcHMpKVxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLmNvbXBvbmVudERpZFVwZGF0ZSA9IGZ1bmN0aW9uIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAvLyBJZiBhbiB1cHBlckJvdW5kIGhhcyBub3QgeWV0IGJlZW4gZGV0ZXJtaW5lZCAoZHVlIHRvIHRoZSBjb21wb25lbnQgYmVpbmcgaGlkZGVuXG4gICAgLy8gZHVyaW5nIHRoZSBtb3VudCBldmVudCwgb3IgZHVyaW5nIHRoZSBsYXN0IHJlc2l6ZSksIHRoZW4gY2FsY3VsYXRlIGl0IG5vd1xuICAgIGlmICh0aGlzLnN0YXRlLnVwcGVyQm91bmQgPT09IDApIHtcbiAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuY2xlYXJQZW5kaW5nUmVzaXplVGltZW91dHMoKTtcblxuICAgIGlmICh0aGlzLnJlc2l6ZU9ic2VydmVyKSB7XG4gICAgICB0aGlzLnJlc2l6ZU9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLm9uRW5kID0gZnVuY3Rpb24gb25FbmQoZXZlbnRNYXApIHtcbiAgICBpZiAoZXZlbnRNYXApIHtcbiAgICAgIHJlbW92ZUhhbmRsZXJzKGV2ZW50TWFwKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oYXNNb3ZlZCkge1xuICAgICAgdGhpcy5maXJlQ2hhbmdlRXZlbnQoJ29uQWZ0ZXJDaGFuZ2UnKTtcbiAgICB9IC8vIEFsbG93IGNvbnRyb2xsZWQgdXBkYXRlcyB0byBjb250aW51ZVxuXG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIHBlbmRpbmc6IGZhbHNlXG4gICAgfSk7XG4gICAgdGhpcy5oYXNNb3ZlZCA9IGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5nZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgIHJldHVybiBwcmVwYXJlT3V0VmFsdWUodGhpcy5zdGF0ZS52YWx1ZSk7XG4gIH07XG5cbiAgX3Byb3RvLmdldENsb3Nlc3RJbmRleCA9IGZ1bmN0aW9uIGdldENsb3Nlc3RJbmRleChwaXhlbE9mZnNldCkge1xuICAgIGxldCBtaW5EaXN0ID0gTnVtYmVyLk1BWF9WQUxVRTtcbiAgICBsZXQgY2xvc2VzdEluZGV4ID0gLTE7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWVcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCBsID0gdmFsdWUubGVuZ3RoO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsOyBpICs9IDEpIHtcbiAgICAgIGNvbnN0IG9mZnNldCA9IHRoaXMuY2FsY09mZnNldCh2YWx1ZVtpXSk7XG4gICAgICBjb25zdCBkaXN0ID0gTWF0aC5hYnMocGl4ZWxPZmZzZXQgLSBvZmZzZXQpO1xuXG4gICAgICBpZiAoZGlzdCA8IG1pbkRpc3QpIHtcbiAgICAgICAgbWluRGlzdCA9IGRpc3Q7XG4gICAgICAgIGNsb3Nlc3RJbmRleCA9IGk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb3Nlc3RJbmRleDtcbiAgfTtcblxuICBfcHJvdG8uZ2V0TW91c2VQb3NpdGlvbiA9IGZ1bmN0aW9uIGdldE1vdXNlUG9zaXRpb24oZSkge1xuICAgIHJldHVybiBbZVtcInBhZ2VcIiArIHRoaXMuYXhpc0tleSgpXSwgZVtcInBhZ2VcIiArIHRoaXMub3J0aG9nb25hbEF4aXNLZXkoKV1dO1xuICB9O1xuXG4gIF9wcm90by5nZXRUb3VjaFBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0VG91Y2hQb3NpdGlvbihlKSB7XG4gICAgY29uc3QgdG91Y2ggPSBlLnRvdWNoZXNbMF07XG4gICAgcmV0dXJuIFt0b3VjaFtcInBhZ2VcIiArIHRoaXMuYXhpc0tleSgpXSwgdG91Y2hbXCJwYWdlXCIgKyB0aGlzLm9ydGhvZ29uYWxBeGlzS2V5KCldXTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0S2V5RG93bkV2ZW50TWFwID0gZnVuY3Rpb24gZ2V0S2V5RG93bkV2ZW50TWFwKCkge1xuICAgIHJldHVybiB7XG4gICAgICBrZXlkb3duOiB0aGlzLm9uS2V5RG93bixcbiAgICAgIGtleXVwOiB0aGlzLm9uS2V5VXAsXG4gICAgICBmb2N1c291dDogdGhpcy5vbkJsdXJcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5nZXRNb3VzZUV2ZW50TWFwID0gZnVuY3Rpb24gZ2V0TW91c2VFdmVudE1hcCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbW91c2Vtb3ZlOiB0aGlzLm9uTW91c2VNb3ZlLFxuICAgICAgbW91c2V1cDogdGhpcy5vbk1vdXNlVXBcbiAgICB9O1xuICB9O1xuXG4gIF9wcm90by5nZXRUb3VjaEV2ZW50TWFwID0gZnVuY3Rpb24gZ2V0VG91Y2hFdmVudE1hcCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdG91Y2htb3ZlOiB0aGlzLm9uVG91Y2hNb3ZlLFxuICAgICAgdG91Y2hlbmQ6IHRoaXMub25Ub3VjaEVuZFxuICAgIH07XG4gIH07XG5cbiAgX3Byb3RvLmdldFZhbHVlRnJvbVBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0VmFsdWVGcm9tUG9zaXRpb24ocG9zaXRpb24pIHtcbiAgICBjb25zdCBkaWZmVmFsdWUgPSBwb3NpdGlvbiAvICh0aGlzLnN0YXRlLnNsaWRlckxlbmd0aCAtIHRoaXMuc3RhdGUudGh1bWJTaXplKSAqICh0aGlzLnByb3BzLm1heCAtIHRoaXMucHJvcHMubWluKTtcbiAgICByZXR1cm4gdHJpbUFsaWduVmFsdWUodGhpcy5zdGF0ZS5zdGFydFZhbHVlICsgZGlmZlZhbHVlLCB0aGlzLnByb3BzKTtcbiAgfTtcblxuICBfcHJvdG8uZ2V0RGlmZlBvc2l0aW9uID0gZnVuY3Rpb24gZ2V0RGlmZlBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgbGV0IGRpZmZQb3NpdGlvbiA9IHBvc2l0aW9uIC0gdGhpcy5zdGF0ZS5zdGFydFBvc2l0aW9uO1xuXG4gICAgaWYgKHRoaXMucHJvcHMuaW52ZXJ0KSB7XG4gICAgICBkaWZmUG9zaXRpb24gKj0gLTE7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRpZmZQb3NpdGlvbjtcbiAgfSAvLyBjcmVhdGUgdGhlIGBrZXlkb3duYCBoYW5kbGVyIGZvciB0aGUgaS10aCB0aHVtYlxuICA7XG5cbiAgX3Byb3RvLnJlc2l6ZSA9IGZ1bmN0aW9uIHJlc2l6ZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBzbGlkZXIsXG4gICAgICB0aHVtYjA6IHRodW1iXG4gICAgfSA9IHRoaXM7XG5cbiAgICBpZiAoIXNsaWRlciB8fCAhdGh1bWIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzaXplS2V5ID0gdGhpcy5zaXplS2V5KCk7IC8vIEZvciB0aGUgc2xpZGVyIHNpemUsIHdlIHdhbnQgdG8gdXNlIHRoZSBjbGllbnQgd2lkdGgvaGVpZ2h0LCBleGNsdWRpbmcgYW55IGJvcmRlcnNcblxuICAgIGNvbnN0IHNsaWRlclJlY3QgPSBzbGlkZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3Qgc2xpZGVyU2l6ZSA9IHNsaWRlcltzaXplS2V5XTtcbiAgICBjb25zdCBzbGlkZXJNYXggPSBzbGlkZXJSZWN0W3RoaXMucG9zTWF4S2V5KCldO1xuICAgIGNvbnN0IHNsaWRlck1pbiA9IHNsaWRlclJlY3RbdGhpcy5wb3NNaW5LZXkoKV07IC8vIEZvciB0aGUgdGh1bWIgc2l6ZSwgd2Ugd2FudCB0byB1c2UgdGhlIG91dGVyIHdpZHRoL2hlaWdodCwgaW5jbHVkaW5nIGFueSBib3JkZXJzXG5cbiAgICBjb25zdCB0aHVtYlJlY3QgPSB0aHVtYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCB0aHVtYlNpemUgPSB0aHVtYlJlY3Rbc2l6ZUtleS5yZXBsYWNlKCdjbGllbnQnLCAnJykudG9Mb3dlckNhc2UoKV07XG4gICAgY29uc3QgdXBwZXJCb3VuZCA9IHNsaWRlclNpemUgLSB0aHVtYlNpemU7XG4gICAgY29uc3Qgc2xpZGVyTGVuZ3RoID0gTWF0aC5hYnMoc2xpZGVyTWF4IC0gc2xpZGVyTWluKTtcblxuICAgIGlmICh0aGlzLnN0YXRlLnVwcGVyQm91bmQgIT09IHVwcGVyQm91bmQgfHwgdGhpcy5zdGF0ZS5zbGlkZXJMZW5ndGggIT09IHNsaWRlckxlbmd0aCB8fCB0aGlzLnN0YXRlLnRodW1iU2l6ZSAhPT0gdGh1bWJTaXplKSB7XG4gICAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgICAgdXBwZXJCb3VuZCxcbiAgICAgICAgc2xpZGVyTGVuZ3RoLFxuICAgICAgICB0aHVtYlNpemVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvLyBjYWxjdWxhdGVzIHRoZSBvZmZzZXQgb2YgYSB0aHVtYiBpbiBwaXhlbHMgYmFzZWQgb24gaXRzIHZhbHVlLlxuICA7XG5cbiAgX3Byb3RvLmNhbGNPZmZzZXQgPSBmdW5jdGlvbiBjYWxjT2Zmc2V0KHZhbHVlKSB7XG4gICAgY29uc3QgcmFuZ2UgPSB0aGlzLnByb3BzLm1heCAtIHRoaXMucHJvcHMubWluO1xuXG4gICAgaWYgKHJhbmdlID09PSAwKSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICBjb25zdCByYXRpbyA9ICh2YWx1ZSAtIHRoaXMucHJvcHMubWluKSAvIHJhbmdlO1xuICAgIHJldHVybiByYXRpbyAqIHRoaXMuc3RhdGUudXBwZXJCb3VuZDtcbiAgfSAvLyBjYWxjdWxhdGVzIHRoZSB2YWx1ZSBjb3JyZXNwb25kaW5nIHRvIGEgZ2l2ZW4gcGl4ZWwgb2Zmc2V0LCBpLmUuIHRoZSBpbnZlcnNlIG9mIGBjYWxjT2Zmc2V0YC5cbiAgO1xuXG4gIF9wcm90by5jYWxjVmFsdWUgPSBmdW5jdGlvbiBjYWxjVmFsdWUob2Zmc2V0KSB7XG4gICAgY29uc3QgcmF0aW8gPSBvZmZzZXQgLyB0aGlzLnN0YXRlLnVwcGVyQm91bmQ7XG4gICAgcmV0dXJuIHJhdGlvICogKHRoaXMucHJvcHMubWF4IC0gdGhpcy5wcm9wcy5taW4pICsgdGhpcy5wcm9wcy5taW47XG4gIH07XG5cbiAgX3Byb3RvLmNhbGNPZmZzZXRGcm9tUG9zaXRpb24gPSBmdW5jdGlvbiBjYWxjT2Zmc2V0RnJvbVBvc2l0aW9uKHBvc2l0aW9uKSB7XG4gICAgY29uc3Qge1xuICAgICAgc2xpZGVyXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2xpZGVyUmVjdCA9IHNsaWRlci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBjb25zdCBzbGlkZXJNYXggPSBzbGlkZXJSZWN0W3RoaXMucG9zTWF4S2V5KCldO1xuICAgIGNvbnN0IHNsaWRlck1pbiA9IHNsaWRlclJlY3RbdGhpcy5wb3NNaW5LZXkoKV07IC8vIFRoZSBgcG9zaXRpb25gIHZhbHVlIHBhc3NlZCBpbiBpcyB0aGUgbW91c2UgcG9zaXRpb24gYmFzZWQgb24gdGhlIHdpbmRvdyBoZWlnaHQuXG4gICAgLy8gVGhlIHNsaWRlciBib3VuZGluZyByZWN0IGlzIGJhc2VkIG9uIHRoZSB2aWV3cG9ydCwgc28gd2UgbXVzdCBhZGQgdGhlIHdpbmRvdyBzY3JvbGxcbiAgICAvLyBvZmZzZXQgdG8gbm9ybWFsaXplIHRoZSB2YWx1ZXMuXG5cbiAgICBjb25zdCB3aW5kb3dPZmZzZXQgPSB3aW5kb3dbXCJwYWdlXCIgKyB0aGlzLmF4aXNLZXkoKSArIFwiT2Zmc2V0XCJdO1xuICAgIGNvbnN0IHNsaWRlclN0YXJ0ID0gd2luZG93T2Zmc2V0ICsgKHRoaXMucHJvcHMuaW52ZXJ0ID8gc2xpZGVyTWF4IDogc2xpZGVyTWluKTtcbiAgICBsZXQgcGl4ZWxPZmZzZXQgPSBwb3NpdGlvbiAtIHNsaWRlclN0YXJ0O1xuXG4gICAgaWYgKHRoaXMucHJvcHMuaW52ZXJ0KSB7XG4gICAgICBwaXhlbE9mZnNldCA9IHRoaXMuc3RhdGUuc2xpZGVyTGVuZ3RoIC0gcGl4ZWxPZmZzZXQ7XG4gICAgfVxuXG4gICAgcGl4ZWxPZmZzZXQgLT0gdGhpcy5zdGF0ZS50aHVtYlNpemUgLyAyO1xuICAgIHJldHVybiBwaXhlbE9mZnNldDtcbiAgfSAvLyBTbmFwcyB0aGUgbmVhcmVzdCB0aHVtYiB0byB0aGUgdmFsdWUgY29ycmVzcG9uZGluZyB0byBgcG9zaXRpb25gXG4gIC8vIGFuZCBjYWxscyBgY2FsbGJhY2tgIHdpdGggdGhhdCB0aHVtYidzIGluZGV4LlxuICA7XG5cbiAgX3Byb3RvLmZvcmNlVmFsdWVGcm9tUG9zaXRpb24gPSBmdW5jdGlvbiBmb3JjZVZhbHVlRnJvbVBvc2l0aW9uKHBvc2l0aW9uLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHBpeGVsT2Zmc2V0ID0gdGhpcy5jYWxjT2Zmc2V0RnJvbVBvc2l0aW9uKHBvc2l0aW9uKTtcbiAgICBjb25zdCBjbG9zZXN0SW5kZXggPSB0aGlzLmdldENsb3Nlc3RJbmRleChwaXhlbE9mZnNldCk7XG4gICAgY29uc3QgbmV4dFZhbHVlID0gdHJpbUFsaWduVmFsdWUodGhpcy5jYWxjVmFsdWUocGl4ZWxPZmZzZXQpLCB0aGlzLnByb3BzKTsgLy8gQ2xvbmUgdGhpcy5zdGF0ZS52YWx1ZSBzaW5jZSB3ZSdsbCBtb2RpZnkgaXQgdGVtcG9yYXJpbHlcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgemlsbG93L3JlYWN0L25vLWFjY2Vzcy1zdGF0ZS1pbi1zZXRzdGF0ZVxuXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlLnNsaWNlKCk7XG4gICAgdmFsdWVbY2xvc2VzdEluZGV4XSA9IG5leHRWYWx1ZTsgLy8gUHJldmVudHMgdGhlIHNsaWRlciBmcm9tIHNocmlua2luZyBiZWxvdyBgcHJvcHMubWluRGlzdGFuY2VgXG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aCAtIDE7IGkgKz0gMSkge1xuICAgICAgaWYgKHZhbHVlW2kgKyAxXSAtIHZhbHVlW2ldIDwgdGhpcy5wcm9wcy5taW5EaXN0YW5jZSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5maXJlQ2hhbmdlRXZlbnQoJ29uQmVmb3JlQ2hhbmdlJyk7XG4gICAgdGhpcy5oYXNNb3ZlZCA9IHRydWU7XG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB2YWx1ZVxuICAgIH0sICgpID0+IHtcbiAgICAgIGNhbGxiYWNrKGNsb3Nlc3RJbmRleCk7XG4gICAgICB0aGlzLmZpcmVDaGFuZ2VFdmVudCgnb25DaGFuZ2UnKTtcbiAgICB9KTtcbiAgfSAvLyBjbGVhciBhbGwgcGVuZGluZyB0aW1lb3V0cyB0byBhdm9pZCBlcnJvciBtZXNzYWdlcyBhZnRlciB1bm1vdW50aW5nXG4gIDtcblxuICBfcHJvdG8uY2xlYXJQZW5kaW5nUmVzaXplVGltZW91dHMgPSBmdW5jdGlvbiBjbGVhclBlbmRpbmdSZXNpemVUaW1lb3V0cygpIHtcbiAgICBkbyB7XG4gICAgICBjb25zdCBuZXh0VGltZW91dCA9IHRoaXMucGVuZGluZ1Jlc2l6ZVRpbWVvdXRzLnNoaWZ0KCk7XG4gICAgICBjbGVhclRpbWVvdXQobmV4dFRpbWVvdXQpO1xuICAgIH0gd2hpbGUgKHRoaXMucGVuZGluZ1Jlc2l6ZVRpbWVvdXRzLmxlbmd0aCk7XG4gIH07XG5cbiAgX3Byb3RvLnN0YXJ0ID0gZnVuY3Rpb24gc3RhcnQoaSwgcG9zaXRpb24pIHtcbiAgICBjb25zdCB0aHVtYlJlZiA9IHRoaXNbXCJ0aHVtYlwiICsgaV07XG5cbiAgICBpZiAodGh1bWJSZWYpIHtcbiAgICAgIHRodW1iUmVmLmZvY3VzKCk7XG4gICAgfVxuXG4gICAgY29uc3Qge1xuICAgICAgekluZGljZXNcbiAgICB9ID0gdGhpcy5zdGF0ZTsgLy8gcmVtb3ZlIHdoZXJldmVyIHRoZSBlbGVtZW50IGlzXG5cbiAgICB6SW5kaWNlcy5zcGxpY2UoekluZGljZXMuaW5kZXhPZihpKSwgMSk7IC8vIGFkZCB0byBlbmRcblxuICAgIHpJbmRpY2VzLnB1c2goaSk7XG4gICAgdGhpcy5zZXRTdGF0ZShwcmV2U3RhdGUgPT4gKHtcbiAgICAgIHN0YXJ0VmFsdWU6IHByZXZTdGF0ZS52YWx1ZVtpXSxcbiAgICAgIHN0YXJ0UG9zaXRpb246IHBvc2l0aW9uICE9PSB1bmRlZmluZWQgPyBwb3NpdGlvbiA6IHByZXZTdGF0ZS5zdGFydFBvc2l0aW9uLFxuICAgICAgaW5kZXg6IGksXG4gICAgICB6SW5kaWNlc1xuICAgIH0pKTtcbiAgfTtcblxuICBfcHJvdG8ubW92ZVVwQnlTdGVwID0gZnVuY3Rpb24gbW92ZVVwQnlTdGVwKHN0ZXApIHtcbiAgICBpZiAoc3RlcCA9PT0gdm9pZCAwKSB7XG4gICAgICBzdGVwID0gdGhpcy5wcm9wcy5zdGVwO1xuICAgIH1cblxuICAgIGNvbnN0IG9sZFZhbHVlID0gdGhpcy5zdGF0ZS52YWx1ZVt0aGlzLnN0YXRlLmluZGV4XTsgLy8gaWYgdGhlIHNsaWRlciBpcyBpbnZlcnRlZCBhbmQgaG9yaXpvbnRhbCB3ZSB3YW50IHRvIGhvbm9yIHRoZSBpbnZlcnRlZCB2YWx1ZVxuXG4gICAgY29uc3QgbmV3VmFsdWUgPSB0aGlzLnByb3BzLmludmVydCAmJiB0aGlzLnByb3BzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgPyBvbGRWYWx1ZSAtIHN0ZXAgOiBvbGRWYWx1ZSArIHN0ZXA7XG4gICAgY29uc3QgdHJpbUFsaWduID0gdHJpbUFsaWduVmFsdWUobmV3VmFsdWUsIHRoaXMucHJvcHMpO1xuICAgIHRoaXMubW92ZShNYXRoLm1pbih0cmltQWxpZ24sIHRoaXMucHJvcHMubWF4KSk7XG4gIH07XG5cbiAgX3Byb3RvLm1vdmVEb3duQnlTdGVwID0gZnVuY3Rpb24gbW92ZURvd25CeVN0ZXAoc3RlcCkge1xuICAgIGlmIChzdGVwID09PSB2b2lkIDApIHtcbiAgICAgIHN0ZXAgPSB0aGlzLnByb3BzLnN0ZXA7XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkVmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlW3RoaXMuc3RhdGUuaW5kZXhdOyAvLyBpZiB0aGUgc2xpZGVyIGlzIGludmVydGVkIGFuZCBob3Jpem9udGFsIHdlIHdhbnQgdG8gaG9ub3IgdGhlIGludmVydGVkIHZhbHVlXG5cbiAgICBjb25zdCBuZXdWYWx1ZSA9IHRoaXMucHJvcHMuaW52ZXJ0ICYmIHRoaXMucHJvcHMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/IG9sZFZhbHVlICsgc3RlcCA6IG9sZFZhbHVlIC0gc3RlcDtcbiAgICBjb25zdCB0cmltQWxpZ24gPSB0cmltQWxpZ25WYWx1ZShuZXdWYWx1ZSwgdGhpcy5wcm9wcyk7XG4gICAgdGhpcy5tb3ZlKE1hdGgubWF4KHRyaW1BbGlnbiwgdGhpcy5wcm9wcy5taW4pKTtcbiAgfTtcblxuICBfcHJvdG8ubW92ZSA9IGZ1bmN0aW9uIG1vdmUobmV3VmFsdWUpIHtcbiAgICAvLyBDbG9uZSB0aGlzLnN0YXRlLnZhbHVlIHNpbmNlIHdlJ2xsIG1vZGlmeSBpdCB0ZW1wb3JhcmlseVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB6aWxsb3cvcmVhY3Qvbm8tYWNjZXNzLXN0YXRlLWluLXNldHN0YXRlXG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLnN0YXRlLnZhbHVlLnNsaWNlKCk7XG4gICAgY29uc3Qge1xuICAgICAgaW5kZXhcbiAgICB9ID0gdGhpcy5zdGF0ZTtcbiAgICBjb25zdCB7XG4gICAgICBsZW5ndGhcbiAgICB9ID0gdmFsdWU7IC8vIFNob3J0IGNpcmN1aXQgaWYgdGhlIHZhbHVlIGlzIG5vdCBjaGFuZ2luZ1xuXG4gICAgY29uc3Qgb2xkVmFsdWUgPSB2YWx1ZVtpbmRleF07XG5cbiAgICBpZiAobmV3VmFsdWUgPT09IG9sZFZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBUcmlnZ2VyIG9ubHkgYmVmb3JlIHRoZSBmaXJzdCBtb3ZlbWVudFxuXG5cbiAgICBpZiAoIXRoaXMuaGFzTW92ZWQpIHtcbiAgICAgIHRoaXMuZmlyZUNoYW5nZUV2ZW50KCdvbkJlZm9yZUNoYW5nZScpO1xuICAgIH1cblxuICAgIHRoaXMuaGFzTW92ZWQgPSB0cnVlOyAvLyBpZiBcInBlYXJsaW5nXCIgKD0gdGh1bWJzIHB1c2hpbmcgZWFjaCBvdGhlcikgaXMgZGlzYWJsZWQsXG4gICAgLy8gcHJldmVudCB0aGUgdGh1bWIgZnJvbSBnZXR0aW5nIGNsb3NlciB0aGFuIGBtaW5EaXN0YW5jZWAgdG8gdGhlIHByZXZpb3VzIG9yIG5leHQgdGh1bWIuXG5cbiAgICBjb25zdCB7XG4gICAgICBwZWFybGluZyxcbiAgICAgIG1heCxcbiAgICAgIG1pbixcbiAgICAgIG1pbkRpc3RhbmNlXG4gICAgfSA9IHRoaXMucHJvcHM7XG5cbiAgICBpZiAoIXBlYXJsaW5nKSB7XG4gICAgICBpZiAoaW5kZXggPiAwKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlQmVmb3JlID0gdmFsdWVbaW5kZXggLSAxXTtcblxuICAgICAgICBpZiAobmV3VmFsdWUgPCB2YWx1ZUJlZm9yZSArIG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZUJlZm9yZSArIG1pbkRpc3RhbmNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpbmRleCA8IGxlbmd0aCAtIDEpIHtcbiAgICAgICAgY29uc3QgdmFsdWVBZnRlciA9IHZhbHVlW2luZGV4ICsgMV07XG5cbiAgICAgICAgaWYgKG5ld1ZhbHVlID4gdmFsdWVBZnRlciAtIG1pbkRpc3RhbmNlKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gICAgICAgICAgbmV3VmFsdWUgPSB2YWx1ZUFmdGVyIC0gbWluRGlzdGFuY2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YWx1ZVtpbmRleF0gPSBuZXdWYWx1ZTsgLy8gaWYgXCJwZWFybGluZ1wiIGlzIGVuYWJsZWQsIGxldCB0aGUgY3VycmVudCB0aHVtYiBwdXNoIHRoZSBwcmUtIGFuZCBzdWNjZWVkaW5nIHRodW1icy5cblxuICAgIGlmIChwZWFybGluZyAmJiBsZW5ndGggPiAxKSB7XG4gICAgICBpZiAobmV3VmFsdWUgPiBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnB1c2hTdWNjZWVkaW5nKHZhbHVlLCBtaW5EaXN0YW5jZSwgaW5kZXgpO1xuICAgICAgICB0cmltU3VjY2VlZGluZyhsZW5ndGgsIHZhbHVlLCBtaW5EaXN0YW5jZSwgbWF4KTtcbiAgICAgIH0gZWxzZSBpZiAobmV3VmFsdWUgPCBvbGRWYWx1ZSkge1xuICAgICAgICB0aGlzLnB1c2hQcmVjZWRpbmcodmFsdWUsIG1pbkRpc3RhbmNlLCBpbmRleCk7XG4gICAgICAgIHRyaW1QcmVjZWRpbmcobGVuZ3RoLCB2YWx1ZSwgbWluRGlzdGFuY2UsIG1pbik7XG4gICAgICB9XG4gICAgfSAvLyBOb3JtYWxseSB5b3Ugd291bGQgdXNlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLFxuICAgIC8vIGJ1dCBzaW5jZSB0aGUgc2xpZGVyIGlzIGEgbG93LWxldmVsIGNvbXBvbmVudCxcbiAgICAvLyB0aGUgZXh0cmEgY29tcGxleGl0eSBtaWdodCBiZSB3b3J0aCB0aGUgZXh0cmEgcGVyZm9ybWFuY2UuXG5cblxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdmFsdWVcbiAgICB9LCB0aGlzLmZpcmVDaGFuZ2VFdmVudC5iaW5kKHRoaXMsICdvbkNoYW5nZScpKTtcbiAgfTtcblxuICBfcHJvdG8ucHVzaFN1Y2NlZWRpbmcgPSBmdW5jdGlvbiBwdXNoU3VjY2VlZGluZyh2YWx1ZSwgbWluRGlzdGFuY2UsIGluZGV4KSB7XG4gICAgbGV0IGk7XG4gICAgbGV0IHBhZGRpbmc7XG5cbiAgICBmb3IgKGkgPSBpbmRleCwgcGFkZGluZyA9IHZhbHVlW2ldICsgbWluRGlzdGFuY2U7IHZhbHVlW2kgKyAxXSAhPT0gbnVsbCAmJiBwYWRkaW5nID4gdmFsdWVbaSArIDFdOyBpICs9IDEsIHBhZGRpbmcgPSB2YWx1ZVtpXSArIG1pbkRpc3RhbmNlKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgIHZhbHVlW2kgKyAxXSA9IGFsaWduVmFsdWUocGFkZGluZywgdGhpcy5wcm9wcyk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5wdXNoUHJlY2VkaW5nID0gZnVuY3Rpb24gcHVzaFByZWNlZGluZyh2YWx1ZSwgbWluRGlzdGFuY2UsIGluZGV4KSB7XG4gICAgZm9yIChsZXQgaSA9IGluZGV4LCBwYWRkaW5nID0gdmFsdWVbaV0gLSBtaW5EaXN0YW5jZTsgdmFsdWVbaSAtIDFdICE9PSBudWxsICYmIHBhZGRpbmcgPCB2YWx1ZVtpIC0gMV07IGkgLT0gMSwgcGFkZGluZyA9IHZhbHVlW2ldIC0gbWluRGlzdGFuY2UpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wYXJhbS1yZWFzc2lnblxuICAgICAgdmFsdWVbaSAtIDFdID0gYWxpZ25WYWx1ZShwYWRkaW5nLCB0aGlzLnByb3BzKTtcbiAgICB9XG4gIH07XG5cbiAgX3Byb3RvLmF4aXNLZXkgPSBmdW5jdGlvbiBheGlzS2V5KCkge1xuICAgIGlmICh0aGlzLnByb3BzLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICByZXR1cm4gJ1knO1xuICAgIH0gLy8gRGVmYXVsdHMgdG8gJ2hvcml6b250YWwnO1xuXG5cbiAgICByZXR1cm4gJ1gnO1xuICB9O1xuXG4gIF9wcm90by5vcnRob2dvbmFsQXhpc0tleSA9IGZ1bmN0aW9uIG9ydGhvZ29uYWxBeGlzS2V5KCkge1xuICAgIGlmICh0aGlzLnByb3BzLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnKSB7XG4gICAgICByZXR1cm4gJ1gnO1xuICAgIH0gLy8gRGVmYXVsdHMgdG8gJ2hvcml6b250YWwnXG5cblxuICAgIHJldHVybiAnWSc7XG4gIH07XG5cbiAgX3Byb3RvLnBvc01pbktleSA9IGZ1bmN0aW9uIHBvc01pbktleSgpIHtcbiAgICBpZiAodGhpcy5wcm9wcy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJykge1xuICAgICAgcmV0dXJuIHRoaXMucHJvcHMuaW52ZXJ0ID8gJ2JvdHRvbScgOiAndG9wJztcbiAgICB9IC8vIERlZmF1bHRzIHRvICdob3Jpem9udGFsJ1xuXG5cbiAgICByZXR1cm4gdGhpcy5wcm9wcy5pbnZlcnQgPyAncmlnaHQnIDogJ2xlZnQnO1xuICB9O1xuXG4gIF9wcm90by5wb3NNYXhLZXkgPSBmdW5jdGlvbiBwb3NNYXhLZXkoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgIHJldHVybiB0aGlzLnByb3BzLmludmVydCA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gICAgfSAvLyBEZWZhdWx0cyB0byAnaG9yaXpvbnRhbCdcblxuXG4gICAgcmV0dXJuIHRoaXMucHJvcHMuaW52ZXJ0ID8gJ2xlZnQnIDogJ3JpZ2h0JztcbiAgfTtcblxuICBfcHJvdG8uc2l6ZUtleSA9IGZ1bmN0aW9uIHNpemVLZXkoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMub3JpZW50YXRpb24gPT09ICd2ZXJ0aWNhbCcpIHtcbiAgICAgIHJldHVybiAnY2xpZW50SGVpZ2h0JztcbiAgICB9IC8vIERlZmF1bHRzIHRvICdob3Jpem9udGFsJ1xuXG5cbiAgICByZXR1cm4gJ2NsaWVudFdpZHRoJztcbiAgfTtcblxuICBfcHJvdG8uZmlyZUNoYW5nZUV2ZW50ID0gZnVuY3Rpb24gZmlyZUNoYW5nZUV2ZW50KGV2ZW50KSB7XG4gICAgaWYgKHRoaXMucHJvcHNbZXZlbnRdKSB7XG4gICAgICB0aGlzLnByb3BzW2V2ZW50XShwcmVwYXJlT3V0VmFsdWUodGhpcy5zdGF0ZS52YWx1ZSksIHRoaXMuc3RhdGUuaW5kZXgpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uYnVpbGRUaHVtYlN0eWxlID0gZnVuY3Rpb24gYnVpbGRUaHVtYlN0eWxlKG9mZnNldCwgaSkge1xuICAgIGNvbnN0IHN0eWxlID0ge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXG4gICAgICB0b3VjaEFjdGlvbjogJ25vbmUnLFxuICAgICAgd2lsbENoYW5nZTogdGhpcy5zdGF0ZS5pbmRleCA+PSAwID8gdGhpcy5wb3NNaW5LZXkoKSA6IHVuZGVmaW5lZCxcbiAgICAgIHpJbmRleDogdGhpcy5zdGF0ZS56SW5kaWNlcy5pbmRleE9mKGkpICsgMVxuICAgIH07XG4gICAgc3R5bGVbdGhpcy5wb3NNaW5LZXkoKV0gPSBvZmZzZXQgKyBcInB4XCI7XG4gICAgcmV0dXJuIHN0eWxlO1xuICB9O1xuXG4gIF9wcm90by5idWlsZFRyYWNrU3R5bGUgPSBmdW5jdGlvbiBidWlsZFRyYWNrU3R5bGUobWluLCBtYXgpIHtcbiAgICBjb25zdCBvYmogPSB7XG4gICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgICAgIHdpbGxDaGFuZ2U6IHRoaXMuc3RhdGUuaW5kZXggPj0gMCA/IHRoaXMucG9zTWluS2V5KCkgKyBcIixcIiArIHRoaXMucG9zTWF4S2V5KCkgOiB1bmRlZmluZWRcbiAgICB9O1xuICAgIG9ialt0aGlzLnBvc01pbktleSgpXSA9IG1pbjtcbiAgICBvYmpbdGhpcy5wb3NNYXhLZXkoKV0gPSBtYXg7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICBfcHJvdG8uYnVpbGRNYXJrU3R5bGUgPSBmdW5jdGlvbiBidWlsZE1hcmtTdHlsZShvZmZzZXQpIHtcbiAgICB2YXIgX3JlZjtcblxuICAgIHJldHVybiBfcmVmID0ge1xuICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZSdcbiAgICB9LCBfcmVmW3RoaXMucG9zTWluS2V5KCldID0gb2Zmc2V0LCBfcmVmO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXJUaHVtYnMgPSBmdW5jdGlvbiByZW5kZXJUaHVtYnMob2Zmc2V0KSB7XG4gICAgY29uc3Qge1xuICAgICAgbGVuZ3RoXG4gICAgfSA9IG9mZnNldDtcbiAgICBjb25zdCBzdHlsZXMgPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHN0eWxlc1tpXSA9IHRoaXMuYnVpbGRUaHVtYlN0eWxlKG9mZnNldFtpXSwgaSk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVzID0gW107XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgICByZXNbaV0gPSB0aGlzLnJlbmRlclRodW1iKHN0eWxlc1tpXSwgaSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyVHJhY2tzID0gZnVuY3Rpb24gcmVuZGVyVHJhY2tzKG9mZnNldCkge1xuICAgIGNvbnN0IHRyYWNrcyA9IFtdO1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IG9mZnNldC5sZW5ndGggLSAxO1xuICAgIHRyYWNrcy5wdXNoKHRoaXMucmVuZGVyVHJhY2soMCwgMCwgb2Zmc2V0WzBdKSk7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxhc3RJbmRleDsgaSArPSAxKSB7XG4gICAgICB0cmFja3MucHVzaCh0aGlzLnJlbmRlclRyYWNrKGkgKyAxLCBvZmZzZXRbaV0sIG9mZnNldFtpICsgMV0pKTtcbiAgICB9XG5cbiAgICB0cmFja3MucHVzaCh0aGlzLnJlbmRlclRyYWNrKGxhc3RJbmRleCArIDEsIG9mZnNldFtsYXN0SW5kZXhdLCB0aGlzLnN0YXRlLnVwcGVyQm91bmQpKTtcbiAgICByZXR1cm4gdHJhY2tzO1xuICB9O1xuXG4gIF9wcm90by5yZW5kZXJNYXJrcyA9IGZ1bmN0aW9uIHJlbmRlck1hcmtzKCkge1xuICAgIGxldCB7XG4gICAgICBtYXJrc1xuICAgIH0gPSB0aGlzLnByb3BzO1xuICAgIGNvbnN0IHJhbmdlID0gdGhpcy5wcm9wcy5tYXggLSB0aGlzLnByb3BzLm1pbiArIDE7XG5cbiAgICBpZiAodHlwZW9mIG1hcmtzID09PSAnYm9vbGVhbicpIHtcbiAgICAgIG1hcmtzID0gQXJyYXkuZnJvbSh7XG4gICAgICAgIGxlbmd0aDogcmFuZ2VcbiAgICAgIH0pLm1hcCgoXywga2V5KSA9PiBrZXkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hcmtzID09PSAnbnVtYmVyJykge1xuICAgICAgbWFya3MgPSBBcnJheS5mcm9tKHtcbiAgICAgICAgbGVuZ3RoOiByYW5nZVxuICAgICAgfSkubWFwKChfLCBrZXkpID0+IGtleSkuZmlsdGVyKGtleSA9PiBrZXkgJSBtYXJrcyA9PT0gMCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmtzLm1hcChwYXJzZUZsb2F0KS5zb3J0KChhLCBiKSA9PiBhIC0gYikubWFwKG1hcmsgPT4ge1xuICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5jYWxjT2Zmc2V0KG1hcmspO1xuICAgICAgY29uc3QgcHJvcHMgPSB7XG4gICAgICAgIGtleTogbWFyayxcbiAgICAgICAgY2xhc3NOYW1lOiB0aGlzLnByb3BzLm1hcmtDbGFzc05hbWUsXG4gICAgICAgIHN0eWxlOiB0aGlzLmJ1aWxkTWFya1N0eWxlKG9mZnNldClcbiAgICAgIH07XG4gICAgICByZXR1cm4gdGhpcy5wcm9wcy5yZW5kZXJNYXJrKHByb3BzKTtcbiAgICB9KTtcbiAgfTtcblxuICBfcHJvdG8ucmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIGNvbnN0IG9mZnNldCA9IFtdO1xuICAgIGNvbnN0IHtcbiAgICAgIHZhbHVlXG4gICAgfSA9IHRoaXMuc3RhdGU7XG4gICAgY29uc3QgbCA9IHZhbHVlLmxlbmd0aDtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbDsgaSArPSAxKSB7XG4gICAgICBvZmZzZXRbaV0gPSB0aGlzLmNhbGNPZmZzZXQodmFsdWVbaV0sIGkpO1xuICAgIH1cblxuICAgIGNvbnN0IHRyYWNrcyA9IHRoaXMucHJvcHMud2l0aFRyYWNrcyA/IHRoaXMucmVuZGVyVHJhY2tzKG9mZnNldCkgOiBudWxsO1xuICAgIGNvbnN0IHRodW1icyA9IHRoaXMucmVuZGVyVGh1bWJzKG9mZnNldCk7XG4gICAgY29uc3QgbWFya3MgPSB0aGlzLnByb3BzLm1hcmtzID8gdGhpcy5yZW5kZXJNYXJrcygpIDogbnVsbDtcbiAgICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoJ2RpdicsIHtcbiAgICAgIHJlZjogciA9PiB7XG4gICAgICAgIHRoaXMuc2xpZGVyID0gcjtcbiAgICAgICAgdGhpcy5yZXNpemVFbGVtZW50UmVmLmN1cnJlbnQgPSByO1xuICAgICAgfSxcbiAgICAgIHN0eWxlOiB7XG4gICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnXG4gICAgICB9LFxuICAgICAgY2xhc3NOYW1lOiB0aGlzLnByb3BzLmNsYXNzTmFtZSArICh0aGlzLnByb3BzLmRpc2FibGVkID8gJyBkaXNhYmxlZCcgOiAnJyksXG4gICAgICBvbk1vdXNlRG93bjogdGhpcy5vblNsaWRlck1vdXNlRG93bixcbiAgICAgIG9uQ2xpY2s6IHRoaXMub25TbGlkZXJDbGlja1xuICAgIH0sIHRyYWNrcywgdGh1bWJzLCBtYXJrcyk7XG4gIH07XG5cbiAgcmV0dXJuIFJlYWN0U2xpZGVyO1xufShSZWFjdC5Db21wb25lbnQpO1xuXG5SZWFjdFNsaWRlci5kaXNwbGF5TmFtZSA9ICdSZWFjdFNsaWRlcic7XG5SZWFjdFNsaWRlci5kZWZhdWx0UHJvcHMgPSB7XG4gIG1pbjogMCxcbiAgbWF4OiAxMDAsXG4gIHN0ZXA6IDEsXG4gIHBhZ2VGbjogc3RlcCA9PiBzdGVwICogMTAsXG4gIG1pbkRpc3RhbmNlOiAwLFxuICBkZWZhdWx0VmFsdWU6IDAsXG4gIG9yaWVudGF0aW9uOiAnaG9yaXpvbnRhbCcsXG4gIGNsYXNzTmFtZTogJ3NsaWRlcicsXG4gIHRodW1iQ2xhc3NOYW1lOiAndGh1bWInLFxuICB0aHVtYkFjdGl2ZUNsYXNzTmFtZTogJ2FjdGl2ZScsXG4gIHRyYWNrQ2xhc3NOYW1lOiAndHJhY2snLFxuICBtYXJrQ2xhc3NOYW1lOiAnbWFyaycsXG4gIHdpdGhUcmFja3M6IHRydWUsXG4gIHBlYXJsaW5nOiBmYWxzZSxcbiAgZGlzYWJsZWQ6IGZhbHNlLFxuICBzbmFwRHJhZ0Rpc2FibGVkOiBmYWxzZSxcbiAgaW52ZXJ0OiBmYWxzZSxcbiAgbWFya3M6IFtdLFxuICByZW5kZXJUaHVtYjogcHJvcHMgPT4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgX2V4dGVuZHMoe30sIHByb3BzLCB7XG4gICAgX19zZWxmOiBSZWFjdFNsaWRlcixcbiAgICBfX3NvdXJjZToge1xuICAgICAgZmlsZU5hbWU6IF9qc3hGaWxlTmFtZSxcbiAgICAgIGxpbmVOdW1iZXI6IDM1MyxcbiAgICAgIGNvbHVtbk51bWJlcjogMzFcbiAgICB9XG4gIH0pKSxcbiAgcmVuZGVyVHJhY2s6IHByb3BzID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIF9fc2VsZjogUmVhY3RTbGlkZXIsXG4gICAgX19zb3VyY2U6IHtcbiAgICAgIGZpbGVOYW1lOiBfanN4RmlsZU5hbWUsXG4gICAgICBsaW5lTnVtYmVyOiAzNTQsXG4gICAgICBjb2x1bW5OdW1iZXI6IDMxXG4gICAgfVxuICB9KSksXG4gIHJlbmRlck1hcms6IHByb3BzID0+IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCBfZXh0ZW5kcyh7fSwgcHJvcHMsIHtcbiAgICBfX3NlbGY6IFJlYWN0U2xpZGVyLFxuICAgIF9fc291cmNlOiB7XG4gICAgICBmaWxlTmFtZTogX2pzeEZpbGVOYW1lLFxuICAgICAgbGluZU51bWJlcjogMzU1LFxuICAgICAgY29sdW1uTnVtYmVyOiAzMFxuICAgIH1cbiAgfSkpXG59O1xuUmVhY3RTbGlkZXIucHJvcFR5cGVzID0gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiID8ge1xuICAvKipcbiAgICogVGhlIG1pbmltdW0gdmFsdWUgb2YgdGhlIHNsaWRlci5cbiAgICovXG4gIG1pbjogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gdmFsdWUgb2YgdGhlIHNsaWRlci5cbiAgICovXG4gIG1heDogUHJvcFR5cGVzLm51bWJlcixcblxuICAvKipcbiAgICogVmFsdWUgdG8gYmUgYWRkZWQgb3Igc3VidHJhY3RlZCBvbiBlYWNoIHN0ZXAgdGhlIHNsaWRlciBtYWtlcy5cbiAgICogTXVzdCBiZSBncmVhdGVyIHRoYW4gemVyby5cbiAgICogYG1heCAtIG1pbmAgc2hvdWxkIGJlIGV2ZW5seSBkaXZpc2libGUgYnkgdGhlIHN0ZXAgdmFsdWUuXG4gICAqL1xuICBzdGVwOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gIC8qKlxuICAgKiBUaGUgcmVzdWx0IG9mIHRoZSBmdW5jdGlvbiBpcyB0aGUgdmFsdWUgdG8gYmUgYWRkZWQgb3Igc3VidHJhY3RlZFxuICAgKiB3aGVuIHRoZSBgUGFnZSBVcGAgb3IgYFBhZ2UgRG93bmAga2V5cyBhcmUgcHJlc3NlZC5cbiAgICpcbiAgICogVGhlIGN1cnJlbnQgYHN0ZXBgIHZhbHVlIHdpbGwgYmUgcGFzc2VkIGFzIHRoZSBvbmx5IGFyZ3VtZW50LlxuICAgKiBCeSBkZWZhdWx0LCBwYWdpbmcgd2lsbCBtb2RpZnkgYHN0ZXBgIGJ5IGEgZmFjdG9yIG9mIDEwLlxuICAgKi9cbiAgcGFnZUZuOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogVGhlIG1pbmltYWwgZGlzdGFuY2UgYmV0d2VlbiBhbnkgcGFpciBvZiB0aHVtYnMuXG4gICAqIE11c3QgYmUgcG9zaXRpdmUsIGJ1dCB6ZXJvIG1lYW5zIHRoZXkgY2FuIHNpdCBvbiB0b3Agb2YgZWFjaCBvdGhlci5cbiAgICovXG4gIG1pbkRpc3RhbmNlOiBQcm9wVHlwZXMubnVtYmVyLFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBpbml0aWFsIHBvc2l0aW9ucyBvZiB0aGUgdGh1bWJzIGFuZCB0aGUgbnVtYmVyIG9mIHRodW1icy5cbiAgICpcbiAgICogSWYgYSBudW1iZXIgaXMgcGFzc2VkIGEgc2xpZGVyIHdpdGggb25lIHRodW1iIHdpbGwgYmUgcmVuZGVyZWQuXG4gICAqIElmIGFuIGFycmF5IGlzIHBhc3NlZCBlYWNoIHZhbHVlIHdpbGwgZGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBvbmUgdGh1bWIuXG4gICAqIFRoZSB2YWx1ZXMgaW4gdGhlIGFycmF5IG11c3QgYmUgc29ydGVkLlxuICAgKi9cbiAgZGVmYXVsdFZhbHVlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubnVtYmVyKV0pLFxuXG4gIC8qKlxuICAgKiBMaWtlIGBkZWZhdWx0VmFsdWVgIGJ1dCBmb3JcbiAgICogW2NvbnRyb2xsZWQgY29tcG9uZW50c10oaHR0cDovL2ZhY2Vib29rLmdpdGh1Yi5pby9yZWFjdC9kb2NzL2Zvcm1zLmh0bWwjY29udHJvbGxlZC1jb21wb25lbnRzKS5cbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB6aWxsb3cvcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzXG4gIHZhbHVlOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMubnVtYmVyLCBQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubnVtYmVyKV0pLFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNsaWRlciBtb3ZlcyBob3Jpem9udGFsbHkgKGZyb20gbGVmdCB0byByaWdodClcbiAgICogb3IgdmVydGljYWxseSAoZnJvbSB0b3AgdG8gYm90dG9tKS5cbiAgICovXG4gIG9yaWVudGF0aW9uOiBQcm9wVHlwZXMub25lT2YoWydob3Jpem9udGFsJywgJ3ZlcnRpY2FsJ10pLFxuXG4gIC8qKlxuICAgKiBUaGUgY3NzIGNsYXNzIHNldCBvbiB0aGUgc2xpZGVyIG5vZGUuXG4gICAqL1xuICBjbGFzc05hbWU6IFByb3BUeXBlcy5zdHJpbmcsXG5cbiAgLyoqXG4gICAqIFRoZSBjc3MgY2xhc3Mgc2V0IG9uIGVhY2ggdGh1bWIgbm9kZS5cbiAgICpcbiAgICogSW4gYWRkaXRpb24gZWFjaCB0aHVtYiB3aWxsIHJlY2VpdmUgYSBudW1iZXJlZCBjc3MgY2xhc3Mgb2YgdGhlIGZvcm1cbiAgICogYCR7dGh1bWJDbGFzc05hbWV9LSR7aX1gLCBlLmcuIGB0aHVtYi0wYCwgYHRodW1iLTFgLCAuLi5cbiAgICovXG4gIHRodW1iQ2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuXG4gIC8qKlxuICAgKiBUaGUgY3NzIGNsYXNzIHNldCBvbiB0aGUgdGh1bWIgdGhhdCBpcyBjdXJyZW50bHkgYmVpbmcgbW92ZWQuXG4gICAqL1xuICB0aHVtYkFjdGl2ZUNsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogSWYgYHRydWVgIHRyYWNrcyBiZXR3ZWVuIHRoZSB0aHVtYnMgd2lsbCBiZSByZW5kZXJlZC5cbiAgICovXG4gIHdpdGhUcmFja3M6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBUaGUgY3NzIGNsYXNzIHNldCBvbiB0aGUgdHJhY2tzIGJldHdlZW4gdGhlIHRodW1icy5cbiAgICogSW4gYWRkaXRpb24gdHJhY2sgZnJhZ21lbnQgd2lsbCByZWNlaXZlIGEgbnVtYmVyZWQgY3NzIGNsYXNzIG9mIHRoZSBmb3JtXG4gICAqIGAke3RyYWNrQ2xhc3NOYW1lfS0ke2l9YCwgZS5nLiBgdHJhY2stMGAsIGB0cmFjay0xYCwgLi4uXG4gICAqL1xuICB0cmFja0NsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogSWYgYHRydWVgIHRoZSBhY3RpdmUgdGh1bWIgd2lsbCBwdXNoIG90aGVyIHRodW1ic1xuICAgKiB3aXRoaW4gdGhlIGNvbnN0cmFpbnRzIG9mIGBtaW5gLCBgbWF4YCwgYHN0ZXBgIGFuZCBgbWluRGlzdGFuY2VgLlxuICAgKi9cbiAgcGVhcmxpbmc6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAgdGhlIHRodW1icyBjYW4ndCBiZSBtb3ZlZC5cbiAgICovXG4gIGRpc2FibGVkOiBQcm9wVHlwZXMuYm9vbCxcblxuICAvKipcbiAgICogRGlzYWJsZXMgdGh1bWIgbW92ZSB3aGVuIGNsaWNraW5nIHRoZSBzbGlkZXIgdHJhY2tcbiAgICovXG4gIHNuYXBEcmFnRGlzYWJsZWQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBJbnZlcnRzIHRoZSBzbGlkZXIuXG4gICAqL1xuICBpbnZlcnQ6IFByb3BUeXBlcy5ib29sLFxuXG4gIC8qKlxuICAgKiBTaG93cyBwYXNzZWQgbWFya3Mgb24gdGhlIHRyYWNrLCBpZiB0cnVlIGl0IHNob3dzIGFsbCB0aGUgbWFya3MsXG4gICAqIGlmIGFuIGFycmF5IG9mIG51bWJlcnMgaXQgc2hvd3MganVzdCB0aGUgcGFzc2VkIG1hcmtzLCBpZiBhIG51bWJlciBpcyBwYXNzZWRcbiAgICogaXQgc2hvd3MganVzdCB0aGUgbWFya3MgaW4gdGhhdCBzdGVwczogbGlrZSBwYXNzaW5nIDMgc2hvd3MgdGhlIG1hcmtzIDMsIDYsIDlcbiAgICovXG4gIG1hcmtzOiBQcm9wVHlwZXMub25lT2ZUeXBlKFtQcm9wVHlwZXMuYXJyYXlPZihQcm9wVHlwZXMubnVtYmVyKSwgUHJvcFR5cGVzLmJvb2wsIFByb3BUeXBlcy5udW1iZXJdKSxcblxuICAvKipcbiAgICogVGhlIGNzcyBjbGFzcyBzZXQgb24gdGhlIG1hcmtzLlxuICAgKi9cbiAgbWFya0NsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIGJlZm9yZSBzdGFydGluZyB0byBtb3ZlIGEgdGh1bWIuIFRoZSBjYWxsYmFjayB3aWxsIG9ubHkgYmUgY2FsbGVkIGlmIHRoZVxuICAgKiBhY3Rpb24gd2lsbCByZXN1bHQgaW4gYSBjaGFuZ2UuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHMsIHRoZSBmaXJzdFxuICAgKiBiZWluZyB0aGUgaW5pdGlhbCB2YWx1ZShzKSB0aGUgc2Vjb25kIGJlaW5nIHRodW1iIGluZGV4LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHppbGxvdy9yZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHMsIHppbGxvdy9yZWFjdC9uby11bnVzZWQtcHJvcC10eXBlc1xuICBvbkJlZm9yZUNoYW5nZTogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIENhbGxiYWNrIGNhbGxlZCBvbiBldmVyeSB2YWx1ZSBjaGFuZ2UuXG4gICAqIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCB3aXRoIHR3byBhcmd1bWVudHMsIHRoZSBmaXJzdCBiZWluZyB0aGUgbmV3IHZhbHVlKHMpXG4gICAqIHRoZSBzZWNvbmQgYmVpbmcgdGh1bWIgaW5kZXguXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LWxlblxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgemlsbG93L3JlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wcywgemlsbG93L3JlYWN0L25vLXVudXNlZC1wcm9wLXR5cGVzXG4gIG9uQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIG9ubHkgYWZ0ZXIgbW92aW5nIGEgdGh1bWIgaGFzIGVuZGVkLiBUaGUgY2FsbGJhY2sgd2lsbCBvbmx5IGJlIGNhbGxlZCBpZlxuICAgKiB0aGUgYWN0aW9uIHJlc3VsdGVkIGluIGEgY2hhbmdlLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgd2l0aCB0d28gYXJndW1lbnRzLCB0aGVcbiAgICogZmlyc3QgYmVpbmcgdGhlIHJlc3VsdCB2YWx1ZShzKSB0aGUgc2Vjb25kIGJlaW5nIHRodW1iIGluZGV4LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG1heC1sZW5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHppbGxvdy9yZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHMsIHppbGxvdy9yZWFjdC9uby11bnVzZWQtcHJvcC10eXBlc1xuICBvbkFmdGVyQ2hhbmdlOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHRoZSBzbGlkZXIgaXMgY2xpY2tlZCAodGh1bWIgb3IgdHJhY2tzKS5cbiAgICogUmVjZWl2ZXMgdGhlIHZhbHVlIGF0IHRoZSBjbGlja2VkIHBvc2l0aW9uIGFzIGFyZ3VtZW50LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHppbGxvdy9yZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHNcbiAgb25TbGlkZXJDbGljazogUHJvcFR5cGVzLmZ1bmMsXG5cbiAgLyoqXG4gICAqIGFyaWEtbGFiZWwgZm9yIHNjcmVlbi1yZWFkZXJzIHRvIGFwcGx5IHRvIHRoZSB0aHVtYnMuXG4gICAqIFVzZSBhbiBhcnJheSBmb3IgbW9yZSB0aGFuIG9uZSB0aHVtYi5cbiAgICogVGhlIGxlbmd0aCBvZiB0aGUgYXJyYXkgbXVzdCBtYXRjaCB0aGUgbnVtYmVyIG9mIHRodW1icyBpbiB0aGUgdmFsdWUgYXJyYXkuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgemlsbG93L3JlYWN0L3JlcXVpcmUtZGVmYXVsdC1wcm9wc1xuICBhcmlhTGFiZWw6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpXSksXG5cbiAgLyoqXG4gICAqIGFyaWEtbGFiZWxsZWRieSBmb3Igc2NyZWVuLXJlYWRlcnMgdG8gYXBwbHkgdG8gdGhlIHRodW1icy5cbiAgICogVXNlZCB3aGVuIHNsaWRlciByZW5kZXJlZCB3aXRoIHNlcGFyYXRlIGxhYmVsLlxuICAgKiBVc2UgYW4gYXJyYXkgZm9yIG1vcmUgdGhhbiBvbmUgdGh1bWIuXG4gICAqIFRoZSBsZW5ndGggb2YgdGhlIGFycmF5IG11c3QgbWF0Y2ggdGhlIG51bWJlciBvZiB0aHVtYnMgaW4gdGhlIHZhbHVlIGFycmF5LlxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHppbGxvdy9yZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHNcbiAgYXJpYUxhYmVsbGVkYnk6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5hcnJheU9mKFByb3BUeXBlcy5zdHJpbmcpXSksXG5cbiAgLyoqXG4gICAqIGFyaWEtdmFsdWV0ZXh0IGZvciBzY3JlZW4tcmVhZGVycy5cbiAgICogQ2FuIGJlIGEgc3RhdGljIHN0cmluZywgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBzdHJpbmcuXG4gICAqIFRoZSBmdW5jdGlvbiB3aWxsIGJlIHBhc3NlZCBhIHNpbmdsZSBhcmd1bWVudCxcbiAgICogYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICAgKlxuICAgKiAgICAgc3RhdGUgPT4gYFZhbHVlOiAke3N0YXRlLnZhbHVlfWBcbiAgICpcbiAgICogLSBgc3RhdGUuaW5kZXhgIHtgbnVtYmVyYH0gdGhlIGluZGV4IG9mIHRoZSB0aHVtYlxuICAgKiAtIGBzdGF0ZS52YWx1ZWAge2BudW1iZXJgIHwgYGFycmF5YH0gdGhlIGN1cnJlbnQgdmFsdWUgc3RhdGVcbiAgICogLSBgc3RhdGUudmFsdWVOb3dgIHtgbnVtYmVyYH0gdGhlIHZhbHVlIG9mIHRoZSB0aHVtYiAoaS5lLiBhcmlhLXZhbHVlbm93KVxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHppbGxvdy9yZWFjdC9yZXF1aXJlLWRlZmF1bHQtcHJvcHNcbiAgYXJpYVZhbHVldGV4dDogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmNdKSxcblxuICAvKipcbiAgICogUHJvdmlkZSBhIGN1c3RvbSByZW5kZXIgZnVuY3Rpb24gZm9yIHRoZSB0cmFjayBub2RlLlxuICAgKiBUaGUgcmVuZGVyIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIHR3byBhcmd1bWVudHMsXG4gICAqIGFuIG9iamVjdCB3aXRoIHByb3BzIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHlvdXIgaGFuZGxlIG5vZGUsXG4gICAqIGFuZCBhbiBvYmplY3Qgd2l0aCB0cmFjayBhbmQgc2xpZGVyIHN0YXRlOlxuICAgKlxuICAgKiAgICAgKHByb3BzLCBzdGF0ZSkgPT4gPGRpdiB7Li4ucHJvcHN9IC8+XG4gICAqXG4gICAqIC0gYHByb3BzYCB7YG9iamVjdGB9IHByb3BzIHRvIGJlIHNwcmVhZCBpbnRvIHlvdXIgdHJhY2sgbm9kZVxuICAgKiAtIGBzdGF0ZS5pbmRleGAge2BudW1iZXJgfSB0aGUgaW5kZXggb2YgdGhlIHRyYWNrXG4gICAqIC0gYHN0YXRlLnZhbHVlYCB7YG51bWJlcmAgfCBgYXJyYXlgfSB0aGUgY3VycmVudCB2YWx1ZSBzdGF0ZVxuICAgKi9cbiAgcmVuZGVyVHJhY2s6IFByb3BUeXBlcy5mdW5jLFxuXG4gIC8qKlxuICAgKiBQcm92aWRlIGEgY3VzdG9tIHJlbmRlciBmdW5jdGlvbiBmb3IgZHluYW1pYyB0aHVtYiBjb250ZW50LlxuICAgKiBUaGUgcmVuZGVyIGZ1bmN0aW9uIHdpbGwgYmUgcGFzc2VkIHR3byBhcmd1bWVudHMsXG4gICAqIGFuIG9iamVjdCB3aXRoIHByb3BzIHRoYXQgc2hvdWxkIGJlIGFkZGVkIHRvIHlvdXIgdGh1bWIgbm9kZSxcbiAgICogYW5kIGFuIG9iamVjdCB3aXRoIHRodW1iIGFuZCBzbGlkZXIgc3RhdGU6XG4gICAqXG4gICAqICAgICAocHJvcHMsIHN0YXRlKSA9PiA8ZGl2IHsuLi5wcm9wc30gLz5cbiAgICpcbiAgICogLSBgcHJvcHNgIHtgb2JqZWN0YH0gcHJvcHMgdG8gYmUgc3ByZWFkIGludG8geW91ciB0aHVtYiBub2RlXG4gICAqIC0gYHN0YXRlLmluZGV4YCB7YG51bWJlcmB9IHRoZSBpbmRleCBvZiB0aGUgdGh1bWJcbiAgICogLSBgc3RhdGUudmFsdWVgIHtgbnVtYmVyYCB8IGBhcnJheWB9IHRoZSBjdXJyZW50IHZhbHVlIHN0YXRlXG4gICAqIC0gYHN0YXRlLnZhbHVlTm93YCB7YG51bWJlcmB9IHRoZSB2YWx1ZSBvZiB0aGUgdGh1bWIgKGkuZS4gYXJpYS12YWx1ZW5vdylcbiAgICovXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSB6aWxsb3cvcmVhY3QvcmVxdWlyZS1kZWZhdWx0LXByb3BzXG4gIHJlbmRlclRodW1iOiBQcm9wVHlwZXMuZnVuYyxcblxuICAvKipcbiAgICogUHJvdmlkZSBhIGN1c3RvbSByZW5kZXIgZnVuY3Rpb24gZm9yIHRoZSBtYXJrIG5vZGUuXG4gICAqIFRoZSByZW5kZXIgZnVuY3Rpb24gd2lsbCBiZSBwYXNzZWQgb25lIGFyZ3VtZW50LFxuICAgKiBhbiBvYmplY3Qgd2l0aCBwcm9wcyB0aGF0IHNob3VsZCBiZSBhZGRlZCB0byB5b3VyIGhhbmRsZSBub2RlXG4gICAqXG4gICAqICAgICAocHJvcHMpID0+IDxzcGFuIHsuLi5wcm9wc30gLz5cbiAgICpcbiAgICogLSBgcHJvcHNgIHtgb2JqZWN0YH0gcHJvcHMgdG8gYmUgc3ByZWFkIGludG8geW91ciB0cmFjayBub2RlXG4gICAqL1xuICByZW5kZXJNYXJrOiBQcm9wVHlwZXMuZnVuY1xufSA6IHt9O1xudmFyIFJlYWN0U2xpZGVyJDEgPSBSZWFjdFNsaWRlcjtcblxuZXhwb3J0IHsgUmVhY3RTbGlkZXIkMSBhcyBkZWZhdWx0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWFjdFNsaWRlci5tanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-slider/dist/es/dev/components/ReactSlider/ReactSlider.mjs\n");

/***/ })

};
;